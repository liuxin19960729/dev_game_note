## 怎样判断书否是搜索二叉树
```java
搜索二叉数： 
    node 
    left 所有左边的都比 node小 
    right 反之

    方法  
        1.中序遍历  一定是升序 
            static  int preBSDValue=Integer.MIN_VALUE;
    /*
    * 递归检查是否是搜索二叉树
    * */
    public boolean dgcheckBSD(Node head){
        if (head==null) return  true;
        boolean leftBSD = dgcheckBSD(head.left);
        if (!leftBSD) return  leftBSD;
        //和当前值进行比较
        if ((int)head.value<=preBSDValue){
            return  false;
        }
        preBSDValue=(int)head.value;
        boolean rightBSD = dgcheckBSD(head.right);
        return  rightBSD;
    }


    搜索二叉树套路方法
      1.node >left 最大值
      2.node <left 最小值
      3.left right 都是搜索二叉树


    public class RDataBSD {
        public int min;
        public int max;

        public RDataBSD(int min, int max, boolean isBSD) {
            this.min = min;
            this.max = max;
            this.isBSD = isBSD;
        }

        public boolean isBSD;

    }


    public RDataBSD bsd2(Node node){
        if (node==null) return  null;
        int min=(int)node.value;
        int max=(int)node.value;
        boolean isBSD=true;
        RDataBSD ldata = bsd2(node.left);
        RDataBSD rdata = bsd2(node.right);
        //先求 当前节点和 left right 之间都 max min
        if (ldata!=null){
            max=Math.max(max,ldata. max);
            min=Math.min(min,ldata. min);
        }
        if (rdata!=null){
            max=Math.max(max,ldata. max);
            min=Math.min(min,ldata. min);
        }
        //判断是否为当前节点是否是搜索二叉树

        if (ldata!=null&&(!ldata.isBSD||ldata.min>=(int)node.value)){
            isBSD=false;
        }
        if (rdata!=null&&(!rdata.isBSD||rdata.max<=(int)node.value)){
            isBSD=false;
        }
        
        return new RDataBSD(min,max,isBSD);
    }



```


## 完全二叉树
```java
完全二叉树:除了最后一层必须全部是满当，最后一层不满也必须是从左至右依次变满

判断一颗是否是完全二叉树


    public boolean checkCBT(Node head){
        boolean leaf=false;
        Queue<Node> queue=new  LinkedList<Node>();
        queue.add(head);
        Node l=null;
        Node r=null;
        while (!queue.isEmpty()){
            Node poll = queue.poll();
            l=poll.left;
            r=poll.right;
            //l==null&&r!=nul 左无右有  leaf&&(l!=null||r!=null  leaf=trur  后面当节点都该是叶子节点
            if ((l==null&&r!=null)||(leaf&&(l!=null||r!=null))) return false;
            if (l!=null){
                queue.add(l);
            }
            if (r!=null){
                queue.add(r);
            }
            if (r==null|| l==null){//表明叶节点有不全当情况了
                leaf=true;
            }
        }
        return  true;
    }
```



## 判断二叉树是否是满二叉树
```
方法
    1.求最大深度  2.其余节点个数  3.判断是否满足 2^深度-1 


```


## 平衡二叉树
```java
定义 : 棵空树或它的左右两个子树的高度差的绝对值不超过1
 条件 1.节点左边平衡二叉树
     2.节点右边平衡二叉树
     3.两个数都节点高度相差不超过1

(解题方式二叉树都递归套路)

         public class  ReturnType{
        public ReturnType(boolean isBalance, int height) {
            this.isBalance = isBalance;
            this.height = height;
        }

        public boolean isBalance;
        public int height;
        
    }
    
    public boolean isBalanceTree(Node node){
        return  _isBabalceTree(node).isBalance;
    }
    private ReturnType _isBabalceTree(Node node){
        if (node==null) return new ReturnType(true,0);
        ReturnType r1 = _isBabalceTree(node.left);
        ReturnType r2 = _isBabalceTree(node.right);
        int height=Math.max(r1.height,r2.height)+1;// 当前节点高度
        if (Math.abs(r1.height-r2.height)<=1&&r1.isBalance&&r2.isBalance){
            return  new ReturnType(true,height);
        }
        return  new ReturnType(false,height)
        
    }
```

## 公共的最低父节点
```java
    /*
    * 限制  head 是 必须包含 o1 o2 节点
    * */
    public Node lowCommonParent(Node head,Node o1,Node o2){
        /*
        * 遍历到头  or 找到 o1  o2
        *
        * */
        if (head==null||o1==head||o2==head) return head;

        Node l = lowCommonParent(head.left, o1, o2);
        Node r = lowCommonParent(head.right, o1, o2);
        if (l!=null&&r!=null){
            return head;
        }

        return l!=null?l:r;//o1-->o2  o2-->o1   null   ret o1 or o2 or null
    }
```


## 后继节点
```java
     A
   B   C
  D E F G

上面是一棵二叉树找一个节点的后继节点


1.先进行中序遍历并且把节点放到队列
    D B E A F C G
    E 的后继节点就是 A  ,G的后继节点就是 null

时间复杂度 O(N)

2.若任何一个节点都有指向父节点的指针的化
    要求时间复杂度为O(k)  k为当前节点到后继节点的深度差
    public Node afterExtendNode(Node sourceNode) {
         //node  right node 存在 后继节点就是right动词最左节点
        if (sourceNode.right!=null){
            sourceNode=sourceNode.right;
            while (sourceNode.left!=null){
                sourceNode=sourceNode.left;
            }
            return  sourceNode;
        }
        //没有right节点
        Node p=sourceNode.parent;
        while (p!=null&&p.left!=sourceNode){
            sourceNode=sourceNode.parent;
            p=sourceNode.parent;
        }
        return p;
    }
```


## 折纸 凹凸折痕
```
      1凹
   2凹     2凸
3凹  3凸 3凹   3凸   

要求打印n次的顺序就是生成的这种二叉树的中序遍历

```