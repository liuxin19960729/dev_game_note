## 怎样判断书否是搜索二叉树
```java
搜索二叉数： 
    node 
    left 所有左边的都比 node小 
    right 反之

    方法  
        1.中序遍历  一定是升序 
            static  int preBSDValue=Integer.MIN_VALUE;
    /*
    * 递归检查是否是搜索二叉树
    * */
    public boolean dgcheckBSD(Node head){
        if (head==null) return  true;
        boolean leftBSD = dgcheckBSD(head.left);
        if (!leftBSD) return  leftBSD;
        //和当前值进行比较
        if ((int)head.value<=preBSDValue){
            return  false;
        }
        preBSDValue=(int)head.value;
        boolean rightBSD = dgcheckBSD(head.right);
        return  rightBSD;
    }


    搜索二叉树套路方法
      1.node >left 最大值
      2.node <left 最小值
      3.left right 都是搜索二叉树


    public class RDataBSD {
        public int min;
        public int max;

        public RDataBSD(int min, int max, boolean isBSD) {
            this.min = min;
            this.max = max;
            this.isBSD = isBSD;
        }

        public boolean isBSD;

    }


    public RDataBSD bsd2(Node node){
        if (node==null) return  null;
        int min=(int)node.value;
        int max=(int)node.value;
        boolean isBSD=true;
        RDataBSD ldata = bsd2(node.left);
        RDataBSD rdata = bsd2(node.right);
        //先求 当前节点和 left right 之间都 max min
        if (ldata!=null){
            max=Math.max(max,ldata. max);
            min=Math.min(min,ldata. min);
        }
        if (rdata!=null){
            max=Math.max(max,ldata. max);
            min=Math.min(min,ldata. min);
        }
        //判断是否为当前节点是否是搜索二叉树

        if (ldata!=null&&(!ldata.isBSD||ldata.min>=(int)node.value)){
            isBSD=false;
        }
        if (rdata!=null&&(!rdata.isBSD||rdata.max<=(int)node.value)){
            isBSD=false;
        }
        
        return new RDataBSD(min,max,isBSD);
    }



```


## 完全二叉树
```java
完全二叉树:除了最后一层必须全部是满当，最后一层不满也必须是从左至右依次变满

判断一颗是否是完全二叉树


    public boolean checkCBT(Node head){
        boolean leaf=false;
        Queue<Node> queue=new  LinkedList<Node>();
        queue.add(head);
        Node l=null;
        Node r=null;
        while (!queue.isEmpty()){
            Node poll = queue.poll();
            l=poll.left;
            r=poll.right;
            //l==null&&r!=nul 左无右有  leaf&&(l!=null||r!=null  leaf=trur  后面当节点都该是叶子节点
            if ((l==null&&r!=null)||(leaf&&(l!=null||r!=null))) return false;
            if (l!=null){
                queue.add(l);
            }
            if (r!=null){
                queue.add(r);
            }
            if (r==null|| l==null){//表明叶节点有不全当情况了
                leaf=true;
            }
        }
        return  true;
    }
```



## 判断二叉树是否是满二叉树
```
方法
    1.求最大深度  2.其余节点个数  3.判断是否满足 2^深度-1 


```


## 平衡二叉树
```java
定义 : 棵空树或它的左右两个子树的高度差的绝对值不超过1
 条件 1.节点左边平衡二叉树
     2.节点右边平衡二叉树
     3.两个数都节点高度相差不超过1

(解题方式二叉树都递归套路)

         public class  ReturnType{
        public ReturnType(boolean isBalance, int height) {
            this.isBalance = isBalance;
            this.height = height;
        }

        public boolean isBalance;
        public int height;
        
    }
    
    public boolean isBalanceTree(Node node){
        return  _isBabalceTree(node).isBalance;
    }
    private ReturnType _isBabalceTree(Node node){
        if (node==null) return new ReturnType(true,0);
        ReturnType r1 = _isBabalceTree(node.left);
        ReturnType r2 = _isBabalceTree(node.right);
        int height=Math.max(r1.height,r2.height)+1;// 当前节点高度
        if (Math.abs(r1.height-r2.height)<=1&&r1.isBalance&&r2.isBalance){
            return  new ReturnType(true,height);
        }
        return  new ReturnType(false,height)
        
    }
```

## 公共的最低父节点
```java
    /*
    * 限制  head 是 必须包含 o1 o2 节点
    * */
    public Node lowCommonParent(Node head,Node o1,Node o2){
        /*
        * 遍历到头  or 找到 o1  o2
        *
        * */
        if (head==null||o1==head||o2==head) return head;

        Node l = lowCommonParent(head.left, o1, o2);
        Node r = lowCommonParent(head.right, o1, o2);
        if (l!=null&&r!=null){
            return head;
        }

        return l!=null?l:r;//o1-->o2  o2-->o1   null   ret o1 or o2 or null
    }
```


## 后继节点
```java
     A
   B   C
  D E F G

上面是一棵二叉树找一个节点的后继节点


1.先进行中序遍历并且把节点放到队列
    D B E A F C G
    E 的后继节点就是 A  ,G的后继节点就是 null

时间复杂度 O(N)

2.若任何一个节点都有指向父节点的指针的化
    要求时间复杂度为O(k)  k为当前节点到后继节点的深度差
    public Node afterExtendNode(Node sourceNode) {
         //node  right node 存在 后继节点就是right动词最左节点
        if (sourceNode.right!=null){
            sourceNode=sourceNode.right;
            while (sourceNode.left!=null){
                sourceNode=sourceNode.left;
            }
            return  sourceNode;
        }
        //没有right节点
        Node p=sourceNode.parent;
        while (p!=null&&p.left!=sourceNode){
            sourceNode=sourceNode.parent;
            p=sourceNode.parent;
        }
        return p;
    }
```


## 折纸 凹凸折痕
```java
      1凹
   2凹     2凸
3凹  3凸 3凹   3凸   

要求打印n次的顺序就是生成的这种二叉树的中序遍历


    public  static  void  printAT(){
            _printAT(3,1,true);
    }

    private static void  _printAT(int num,int i,boolean auOrtu){
       if (i>num) return;
       _printAT(num,i+1,true);
       String str= auOrtu?i+":凹":i+"凸";
        System.out.println(str);
        _printAT(num,i+1,false);
    }

```

# 图
```
1.宽度优先遍历
    1.需要适用的个表(HashSet...) 来记录
    因为 有向 可能有环 无向 这两种情况可能造成遍历不完
    (去重机制)
    2.创建一个队列 



2.深度优先遍历
    1.栈实现
        1.先方放入传入的节点到stack  和 放入set

        while(!statck.isEmpt()){
            Node node= stack.pop();//弹出栈里面的节点
            //获取h和栈相连的节点

             ArrayList<Node> nodes = node.nodes;

             //遍历

             for (Node node: nodes){
                 //表不存在全部进行压栈 当前节点  和 遍历的node 
                 if(!set.contains(node)){
                    stack.push(curNode);
                    stack.pish(node); 
                    set.add(node);
                    print(node);//打印节点
                    break;      
                 }
             }
        }


        //做后发现栈会在某一个时刻 装下深度的所有节点

        然后在通过whild去玄循环 pop()  他是通过 插叙 set 看是否我们的节点已经进行使用过



    
    2.也需要去重机制


上面Code思想
    拿着我们没有重复使用过的节点找到到底



```

## 无方向的图求边的最小值
```java
1.所有边 按照从小-->到大的循序进行排序(k 算法)  从边的角度
 遍历 排完序的边 (拿到每条边 检查是否存在环)
    存在环  在检查下一条
    不存在 存储 检查下一条 

  怎样检查是否存在环????

        1.集合检测是否存在闭环
           1.开始每个店自己就是一个集合。
           那着遍历的每一个点进行判断

            for(side:sides){
                n1=side.from 
                n2=side.to
                检测 n1 n2这两个点是否在集合里面存在这两个点
                id(set.contiten(你n1)&&set.contiten(你n2)){//存在
                        continue ;是闭环
                }else{//不存在
                    把这两个点放入到集合里面 
                    set.add(n1);
                    set.add(n2)
                }
            }


//简单的实现集合检测
public class MySet {
    private class Node{

    }
    private HashMap<Node,List<Node>> map =null;
    public MySet(List<Node> nodes){//初始化添加每个节点都是一个只有自己的集合
        map =new HashMap<Node, List<Node>>();
        for (Node node : nodes) {
            ArrayList<Node> list = new ArrayList<Node>();
            map.put(node,list);
        }
    }

    public  boolean cycle(Node from ,Node to){
        List<Node> f = map.get(from);
        List<Node> t = map.get(to);
        return  f==t;
    }
    
    public  void  union(Node from ,Node to){
        List<Node> f = map.get(from);
        List<Node> t = map.get(to);
        for (Node node : t) {
            f.add(node);
            map.put(node,f);
        }
    }
}




prim 算法 (从点的角度)    
   1.任意 选取一个点
   2.查询有那些边和这个点进行相连 并且 存储到已经解锁的边两面
   3.在查询的的解锁的边里面选取一个解锁的边(条件:最短并且不造成环路) 并且把他标记已经使用 （查询到环路也标记为已经使用）
   4. 拿着这个点重复 2,3操作  
        当我们拿着的这个点锁连接的点都是解锁的边之后
        就操3步骤

        若有新的未解锁的边,把他们标记为解锁 执行上面的第3步骤
      
         知道未解锁的每一条边都使用这样退出循环 

   5.得出结果
        

```

<!-- 
## Dijkstra算法
```

``` -->



