## 排序总结
```
稳定性 ：相同元素经过排序之后的次序是否维持下来
   次序保持下来  有稳定性

   


选择排序: 不保证稳定性

冒泡排序：保证稳定性 (前提 相等不交换)


插入排序: 保证稳定性 (前提 相等不交换)  

归并排序：: 保证稳定性 (前提 是相等拷贝左边) 

快排 ：做不了稳定性


堆排 :做不了稳定性

桶排序 ：可以做稳定性



基于比较的排序 O(N*logN)的时间复杂度是极限了


```

## hash表
```
hash 表 增删改查时间复杂度是常数级别(大常数)


hash key 
    基础类型 存执值
    引用类型 存储的是对应的内存地址( os 64bit key 大小是存储8字节大小的地址)



```

## 有序表

```
TreeMap
TreeMap


时间复杂度 O(logN)


```


## 链表
```java
单链表逆序重排

public class CusumeLinkList<T> {
    private  Node<T> _root;
    private  Node<T> _tail;
    class Node<T>{
        public Node(T valuel) {
            this.valuel = valuel;
        }
        T valuel;
        Node<T> next;
    }


    public void add(T v){
        if (_root==null){
            _root=new Node<T>(v);
            _tail=_root;
        }else {
            _tail.next=new Node<T>(v);
            _tail=_tail.next;
        }
    }

    /**
     * 链表反转顺序
     */
    public void reserve(){
        _tail=_root;
        _reserve(_root);
        _tail.next=null;
    }

    private Node<T> _reserve(Node<T> node){
        Node<T> tmpRootNode=node;
        if (node.next==null){
            _root=node;
            return node;
        }else {
            Node<T> preNode = _reserve(node.next);
            preNode.next=node;
            return  node;
        }
    }

    public void string() throws Exception {
        if (_root==null) throw  new Exception("no add value");
        Node<T> node=_root;
        while (node!=null){
            System.out.println(node.valuel.toString());
            node=node.next;
        }
    }

    public static void main(String[] args) throws Exception {
        CusumeLinkList<Integer> list =new CusumeLinkList<Integer>();
        list.add(1);
        list.add(2);
        list.add(3);
        list.add(4);
        list.string();
        list.reserve();
        System.out.println("============reserve==============");
        list.string();
    }
}



1.判断单链表是否回文
  1.Stack 全部压栈 
  2. 怎样确定链表的中间节点
    fastPoint 每次走两步
    slowPoint 每次走一步
    fastPoint走完  slowPoint 刚好走到链表的中点


        实现链表求中间的Node节点
     private Node<T> _centerValue(){
           Node<T> slow=null;
           Node<T> quick=_root;
           while (quick!=null){
                if (quick.equals(_root)){
                    slow=_root;
                    quick=quick.next;
                }else {
                    if (quick.next!=null&&quick.next.next!=null){
                          quick=quick.next.next;
                          slow=slow.next;
                    }else {
                        if (quick.next!=null){//下面有才加  下面没有说明刚好走完不加
                            slow=slow.next;
                        }
                        quick=null;
                    }
                }
           }

           return  slow;
     }



```

