序链表
```
1.怎样找到第一个入环节点
    简单方法
    head 开始 查询 hash表  
    if (存在){
        return node (返回的node)就是第一个环节点
    }  else{
        存入hash表
        node.next 在传入这个方法
    }

2.第二种方式求出 第一个入环点

 判断链表欧环并且环的入口
   fast 2 step 

   slow 1 step

 若fast 遇到 next节点未null说明不存在环链表
 
 fast继续走 slow 当他们在换里面遇到的时候  在把fast移到 head 然后 fast 和 slow 都走 1step  相遇的节点就是环入口节点 
```
链表环入口原理图
![链表环入口](./img/链表环入口.png)


### 单链表寻找第一个入口环节点的Code实现
```java
    //寻找第一个入环节点
    public Node findFirstCycleNode(Node head) {
        if (head == null || head.next == null || head.next.next == null) return null;
        Node slow = head.next;
        Node fast = head.next.next;
        // 非cycle null
        while (slow != fast) {
            if (fast==null||fast.next==null||fast.next.next==null) return null;
            fast=fast.next.next;
            slow=slow.next;
        }
         //相遇 就是对一个入口环
        fast=head;
        while (fast!=head){
            fast=fast.next;
            slow=slow.next;
        }
        return  head;
    }


     // 添加
    public void add(T v){
        if (v==null) throw  new NullPointerException("value is null");
        Node node = new Node(v);
        if (_head==null){
            _head=node;
            _tail=node;
            return;
        }
        _tail.next=node;
        _tail=_tail.next;
    }

    /*
    * 删除所有指定元素的节点
    * */
    public void  del(T v){
        if (v==null) throw  new NullPointerException("value is null");
        Node node=_head;
        Node preNode=_head;
        while (node!=null){
            if (node.v.equals(v)&&node.equals(_head)){//头节点相同
                _head=node.next;
                node=node.next;
                preNode=node.next;
            }else if (node.v.equals(v)&&!node.equals(_head)){//不是头节点相同
                Node next=node.next;
                preNode.next=next;
            }else {//不相同
                preNode=node;
                node=node.next;
            }
        }
    }





    
```


### 判断两个不循环的链表是否相交 并且返回相交的节点

```java
    // 两条循环链表是否有交
    public  Node noLoop(Node head1,Node head2){
        Node cur1=head1;
        Node cur2=head2;
        int cnt=0;
        while (cur1!=null){
            cnt++;
            cur1=cur1.next;
        }
        while (cur2.next!=null){
            cnt--;
            cur2=cur2.next;
        }
        if (cur1!=cur2) return null;//不想交
        //相交
        // cur1  > cur2重定位
        cur1 =cnt>0?head1:head2;
        cur2=cur1==head1?head2:head1;
        cnt=Math.abs(cnt);
        //先走差距步数
        while (cnt!=0){
            cnt--;
            cur1=cur2.next;
        }
        while (cur1!=cur2){
            cur1=cur1.next;
            cur2=cur2.next;
        }
        return  cur1;
    }
```


### 两个链表 一个链表有环  一个无环 他们是一定不相交的


两个链表都有环
```
1.独立的有环链表

2.相交节点一个

3.相交的节点 环节点个数那么多个
```

## 二叉树
```
二叉树 遍历 每个节点都会回到3次

进入--f（node）
call -f(node.left--)-->回到 f
call -f(node.right--)-->回到 f

返回整个 f() 



递归打印
    先序 (头左右)

    中序(左 头  右)


```


## 二叉树非递归先序打印
```java
    /*
    * 先序打印
    * */
    public void prePirint(Node head){
        if (head==null) throw new NullPointerException("prePirint param null");
        Stack<Node> stack = new Stack<>();
        stack.push(head);
        while (!stack.isEmpty()){
            Node pop = stack.pop();
            System.out.println(pop.value);
            if (pop.right!=null) stack.push(pop.right);
            if (pop.left!=null) stack.push(pop.left);
        }
    }
    private class Node {
        public Node(T value) {
            this.value = value;
        }

        T value;
        Node left;
        Node right;
    }
```


## 非递归二叉树后序排序
```java    
/*
    * 后序打印
    * */
    public void afterPrint(Node head){
        if (head==null) throw new NullPointerException("prePirint param null");
        Stack<Node> s1 = new Stack<>();
        Stack<Node> s2 = new Stack<>();
        s1.push(head);
        while (!s1.isEmpty()){
            Node pop = s1.pop();
            s2.push(pop);
            if (pop.left!=null) s1.push(pop.left);
            if (pop.right!=null) s1.push(pop.right);
        }
        //打印
        while (!s2.isEmpty()){
            Node pop = s2.pop();
            System.out.println(pop.value);
        }
    }
```


## 二叉树中序打印非递归
```java
    public void centerPrint(Node head){
        if (head==null) throw new NullPointerException("prePirint param null");
        Stack<Node> s1 = new Stack<>();
        _allLeftPush(head,s1);//先进行压栈
        while (!s1.isEmpty()){
            Node pop = s1.pop();
            System.out.println(pop.value);
            if (pop.right!=null) _allLeftPush(pop.right,s1);
        }
    }
    private void _allLeftPush(Node node,Stack<Node> stack){
        if (node==null) return;
        stack.push(node);
        while (node.left!=null){
            node=node.left;
            stack.push(node);
        }
    }
```

## 二叉树的宽度遍历
```java
    /*
    * 宽度遍历  
    * */
    public void wPrint(Node head){
        if (head==null) throw new NullPointerException("prePirint param null");
        Queue<Node> queue =new LinkedList<Node>();
        queue.add(head);
        while (!queue.isEmpty()){
            Node peek = queue.poll();
            System.out.println(peek.value);
            if (peek.left!=null) queue.add(peek.left);
            if (peek.right!=null) queue.add(peek.right);
        }
    }
```
## 二叉树最大宽度  hash表的方式
```java
  /*
     * 宽度的最大节点数
     * */
    public int wMaxCount(Node head){
        if (head==null) throw new NullPointerException("prePirint param null");
        Queue<Node> queue =new LinkedList<Node>();
        queue.add(head);
        HashMap<Node, Integer> map = new HashMap<>();
        map.put(head,1);
        int curLevel=1;
        int max=-1;
        int count=0;
        while (!queue.isEmpty()){
            Node nd = queue.poll();
            if (curLevel==map.get(nd).intValue()){
                count++;
            }else {
                curLevel++;//更新当前层级
                max=Math.max(max,count);
                count=1;
            }
            if (nd.left!=null){
                queue.add(nd.left);
                map.put(nd.left,curLevel+1);
            };
            if (nd.right!=null) {
                queue.add(nd.right);
                map.put(nd.right,curLevel+1);
            };
        }
        return  max;
    }
```

## no hashmap 计算宽度
```java
    /*
     * 宽度的最大节点数  no hashmap
     * */
    public int wMaxCounts(Node head){
        if (head==null) throw new NullPointerException("prePirint param null");
        int max =-1;
        int count=0;
        Queue<Node> queue =new LinkedList<>();
        queue.add(head);
        Node currentNodeEnd=head;
        Node nextNodeEnd=null;
        while (!queue.isEmpty()){
            Node nd = queue.poll();
            count++;
            if (nd.left!=null){
                queue.add(nd.left);
                nextNodeEnd=nd.left;
            }
            if (nd.right!=null){
                queue.add(nd.right);
                nextNodeEnd=nd.right;
            }

            if (currentNodeEnd==nd){//结束第一层
                max=Math.max(max,count);
                count=0;
                currentNodeEnd=nextNodeEnd;
            }
        }

        return  max;
    }
```
