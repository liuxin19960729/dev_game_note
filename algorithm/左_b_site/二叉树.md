链表
```
1.怎样找到第一个入环节点
    简单方法
    head 开始 查询 hash表  
    if (存在){
        return node (返回的node)就是第一个环节点
    }  else{
        存入hash表
        node.next 在传入这个方法
    }

2.第二种方式求出 第一个入环点

 判断链表欧环并且环的入口
   fast 2 step 

   slow 1 step

 若fast 遇到 next节点未null说明不存在环链表
 
 fast继续走 slow 当他们在换里面遇到的时候  在把fast移到 head 然后 fast 和 slow 都走 1step  相遇的节点就是环入口节点 
```
链表环入口原理图
![链表环入口](./img/链表环入口.png)


### 单链表寻找第一个入口环节点的Code实现
```java
    //寻找第一个入环节点
    public Node findFirstCycleNode(Node head) {
        if (head == null || head.next == null || head.next.next == null) return null;
        Node slow = head.next;
        Node fast = head.next.next;
        // 非cycle null
        while (slow != fast) {
            if (fast==null||fast.next==null||fast.next.next==null) return null;
            fast=fast.next.next;
            slow=slow.next;
        }
         //相遇 就是对一个入口环
        fast=head;
        while (fast!=head){
            fast=fast.next;
            slow=slow.next;
        }
        return  head;
    }


     // 添加
    public void add(T v){
        if (v==null) throw  new NullPointerException("value is null");
        Node node = new Node(v);
        if (_head==null){
            _head=node;
            _tail=node;
            return;
        }
        _tail.next=node;
        _tail=_tail.next;
    }

    /*
    * 删除所有指定元素的节点
    * */
    public void  del(T v){
        if (v==null) throw  new NullPointerException("value is null");
        Node node=_head;
        Node preNode=_head;
        while (node!=null){
            if (node.v.equals(v)&&node.equals(_head)){//头节点相同
                _head=node.next;
                node=node.next;
                preNode=node.next;
            }else if (node.v.equals(v)&&!node.equals(_head)){//不是头节点相同
                Node next=node.next;
                preNode.next=next;
            }else {//不相同
                preNode=node;
                node=node.next;
            }
        }
    }





    
```


### 判断两个不循环的链表是否相交 并且返回相交的节点

```java
    // 两条循环链表是否有交
    public  Node noLoop(Node head1,Node head2){
        Node cur1=head1;
        Node cur2=head2;
        int cnt=0;
        while (cur1!=null){
            cnt++;
            cur1=cur1.next;
        }
        while (cur2.next!=null){
            cnt--;
            cur2=cur2.next;
        }
        if (cur1!=cur2) return null;//不想交
        //相交
        // cur1  > cur2重定位
        cur1 =cnt>0?head1:head2;
        cur2=cur1==head1?head2:head1;
        cnt=Math.abs(cnt);
        //先走差距步数
        while (cnt!=0){
            cnt--;
            cur1=cur2.next;
        }
        while (cur1!=cur2){
            cur1=cur1.next;
            cur2=cur2.next;
        }
        return  cur1;
    }
```


### 两个链表 一个链表有环  一个无环 他们是一定不相交的


两个链表都有环
```
1.独立的有环链表

2.相交节点一个

3.相交的节点 环节点个数那么多个
```

## 二叉树
```
二叉树 遍历 每个节点都会回到3次

进入--f（node）
call -f(node.left--)-->回到 f
call -f(node.right--)-->回到 f

返回整个 f() 



递归打印
    先序 (头左右)

    中序(左 头  右)


```


