## 有序表并查集
1.
```java
岛问题
一个矩阵只有0和1
  1只能上下左右相连(叫做一个岛)  注意斜线不能连
例  001010
    111010
    100100
    000000

    有三个岛
        1
     1 1 1
     1


     1
     1

     1

     只有上面的三个岛


 1.方法一
  思路：
    从第一排起从第一个开始遍历
    当遇到1 把他所有的上下左右能相连的全部感染成2
    然后接着上面的地方在镜像查询 和上面的过程一样
    感染几次就有几个岛


public class DaoQuestion {
    public static void main(String[] args) {
        DaoQuestion dq=new DaoQuestion();
    byte martix[][]={
            {0,0,1,0,1,0,},
            {1,1,1,0,1,0,},
            {1,0,0,1,0,0,},
            {0,0,0,0,0,0,},
    };
        for (int i = 0; i < martix.length; i++) {
        System.out.println(Arrays.toString(martix[i]));
    }
        System.out.println(dq.defaultSolu(martix));
        System.out.println("=========================");
        for (int i = 0; i < martix.length; i++) {
        System.out.println(Arrays.toString(martix[i]));
    }
}

    public int defaultSolu(byte[][] martix){
        int v=0;
        for (int h = 0; h < martix.length; h++) {//行列
            for (int l = 0; l < martix[0].length; l++) {
                if (martix[h][l]==1){
                    v++;
                    //进行修改
                    _edit(martix,new  Martix(h,l));
                }
            }
        }
        return v;
    }
class  Martix{
    int h;

    public Martix(int h, int l) {
        this.h = h;
        this.l = l;
    }

    int l;

}
    private void  _edit(byte[][] martixs,Martix martix){
        Stack<Martix> stack =new Stack<Martix>();
        stack.push(martix);
        while (!stack.isEmpty()){
            Martix pop = stack.pop();
            martixs[pop.h][pop.l]=2;
            if (pop.l-1>=0 &&martixs[pop.h][pop.l-1]==1){
                stack.push(new Martix(pop.h,pop.l-1));
            }
            if (pop.l+1<martixs[0].length &&martixs[pop.h][pop.l+1]==1){
                stack.push(new Martix(pop.h,pop.l+1));
            }
            if (pop.h+1<martixs.length&&martixs[pop.h+1][pop.l]==1){
                stack.push(new Martix(pop.h+1,pop.l));
            }
        }
    }
}







1.并查集结构(效率非常高支持集合合并)
   search 0(1)
   union 0(1)

但是传统的数据结构做集合就效率就不是很好
   链表
     search >0(1)
     union 0(1)
   hash 表
     search 0(1)
     union> 0(1)

  并查集结构 图的方式
  

  并查集实现

public class CheckAndASet<E> {
    public CheckAndASet head;
    public int itemCount;
    private E _val;

    public CheckAndASet(E v) {
        this._val = v;
        init();
    }

    public CheckAndASet() {
        this._val = null;
        init();
    }

    public static void union(CheckAndASet s1, CheckAndASet s2) {
          if (CheckAndASet.isSameSet(s1,s2)) return;//已经是一个集合
          if (s1.itemCount>=s2.itemCount){
              s2.head=s1;
              s1.itemCount+= s1.itemCount;
              return;
          }
        s1.head=s2;
        s2.itemCount+=s1.itemCount;
    }
    /*
     * 是否是同一个集合
     * */
    public static boolean isSameSet(CheckAndASet s1, CheckAndASet s2) {
        if (s1 == null || s2 == null) return false;
        Stack<CheckAndASet> stacka =new Stack<>();
        Stack<CheckAndASet> stackb =new Stack<>();
        CheckAndASet head1 = s1.head;
        CheckAndASet head2 = s2.head;
        while (head1.head != head1 || head2.head != head1) {
            if (head1!=head1.head){
                head1 = head1.head;
                stacka.push(head1);
            }
            if (head2.head != head1){
                head2 = head2.head;
                stacka.push(head2);
            }
        }
        //优化(链过长对链进行扁平化操作)
        while (!stacka.isEmpty()){
            CheckAndASet pop = stacka.pop();
             pop.head=head1;
        }
        while (!stackb.isEmpty()){
            CheckAndASet pop = stackb.pop();
            pop.head=head2;
        }
        return head1 == head2;
    }

    private void init() {
        head = this;
        itemCount = 1;
    }

    public E get_val() {
        return _val;
    }

    public void set_val(E _val) {
        this._val = _val;
    }
}



进阶:如何设计一个并行算法

  2 核cpu 
  1.将一张大的举证按照例的一半分成两个
  2.每张举证分别扫苗到-- left张记录每个到最右边的边界若没到达边界则不记录
     right 记录左边的边界 不存在最左则不记录
     例 
       
       LEFT       RIGHT 
       A  b1      C b1
       B  b1      C b2
       B  b2      D b1
       A  b2      D b2
     在用并查集 设置 A   B  C  D 四个集合
     若边界相邻则 把他们集合合并 并且  totalcount-1

     当我们比较边界不是相邻或者 两个点在同一个集合则不用管了




  多核cpu 我们可以把一张大的集合划分为多个块计算每个块岛的数量在依次计算每个块的 上  下  左  右的 边界  在把每张表依次合并 最终就能计算出一张大的表岛的数量
```


## KMP 
```

```

