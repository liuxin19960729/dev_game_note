## 有序表并查集
1.
```java
岛问题
一个矩阵只有0和1
  1只能上下左右相连(叫做一个岛)  注意斜线不能连
例  001010
    111010
    100100
    000000

    有三个岛
        1
     1 1 1
     1


     1
     1

     1

     只有上面的三个岛


 1.方法一
  思路：
    从第一排起从第一个开始遍历
    当遇到1 把他所有的上下左右能相连的全部感染成2
    然后接着上面的地方在镜像查询 和上面的过程一样
    感染几次就有几个岛


public class DaoQuestion {
    public static void main(String[] args) {
        DaoQuestion dq=new DaoQuestion();
    byte martix[][]={
            {0,0,1,0,1,0,},
            {1,1,1,0,1,0,},
            {1,0,0,1,0,0,},
            {0,0,0,0,0,0,},
    };
        for (int i = 0; i < martix.length; i++) {
        System.out.println(Arrays.toString(martix[i]));
    }
        System.out.println(dq.defaultSolu(martix));
        System.out.println("=========================");
        for (int i = 0; i < martix.length; i++) {
        System.out.println(Arrays.toString(martix[i]));
    }
}

    public int defaultSolu(byte[][] martix){
        int v=0;
        for (int h = 0; h < martix.length; h++) {//行列
            for (int l = 0; l < martix[0].length; l++) {
                if (martix[h][l]==1){
                    v++;
                    //进行修改
                    _edit(martix,new  Martix(h,l));
                }
            }
        }
        return v;
    }
class  Martix{
    int h;

    public Martix(int h, int l) {
        this.h = h;
        this.l = l;
    }

    int l;

}
    private void  _edit(byte[][] martixs,Martix martix){
        Stack<Martix> stack =new Stack<Martix>();
        stack.push(martix);
        while (!stack.isEmpty()){
            Martix pop = stack.pop();
            martixs[pop.h][pop.l]=2;
            if (pop.l-1>=0 &&martixs[pop.h][pop.l-1]==1){
                stack.push(new Martix(pop.h,pop.l-1));
            }
            if (pop.l+1<martixs[0].length &&martixs[pop.h][pop.l+1]==1){
                stack.push(new Martix(pop.h,pop.l+1));
            }
            if (pop.h+1<martixs.length&&martixs[pop.h+1][pop.l]==1){
                stack.push(new Martix(pop.h+1,pop.l));
            }
        }
    }
}


进阶:如何设计一个并行算法




1.并查集结构(效率非常高支持集合合并)
   search 0(1)
   union 0(1)

但是传统的数据结构做集合就效率就不是很好
   链表
     search >0(1)
     union 0(1)
   hash 表
     search 0(1)
     union> 0(1)

  并查集结构 图的方式
  

  并查集实现

public class CheckAndASet<E> {
    public CheckAndASet head;
    public int itemCount;
    private E _val;

    public CheckAndASet(E v) {
        this._val = v;
        init();
    }

    public CheckAndASet() {
        this._val = null;
        init();
    }

    public static void union(CheckAndASet s1, CheckAndASet s2) {
          if (CheckAndASet.isSameSet(s1,s2)) return;//已经是一个集合
          if (s1.itemCount>=s2.itemCount){
              s2.head=s1;
              s1.itemCount++;
              return;
          }
        s1.head=s2;
        s2.itemCount++;
    }
    /*
     * 是否是同一个集合
     * */
    public static boolean isSameSet(CheckAndASet s1, CheckAndASet s2) {
        if (s1 == null || s2 == null) return false;
        Stack<CheckAndASet> stacka =new Stack<>();
        Stack<CheckAndASet> stackb =new Stack<>();
        CheckAndASet head1 = s1.head;
        CheckAndASet head2 = s2.head;
        while (head1.head != head1 || head2.head != head1) {
            if (head1!=head1.head){
                head1 = head1.head;
                stacka.push(head1);
            }
            if (head2.head != head1){
                head2 = head2.head;
                stacka.push(head2);
            }
        }
        //优化
        while (!stacka.isEmpty()){
            CheckAndASet pop = stacka.pop();
             pop.head=head1;
        }
        while (!stackb.isEmpty()){
            CheckAndASet pop = stackb.pop();
            pop.head=head2;
        }
        return head1 == head2;
    }

    private void init() {
        head = this;
        itemCount = 1;
    }

    public E get_val() {
        return _val;
    }

    public void set_val(E _val) {
        this._val = _val;
    }
}

```