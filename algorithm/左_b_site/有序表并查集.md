## 有序表并查集
1.
```java
岛问题
一个矩阵只有0和1
  1只能上下左右相连(叫做一个岛)  注意斜线不能连
例  001010
    111010
    100100
    000000

    有三个岛
        1
     1 1 1
     1


     1
     1

     1

     只有上面的三个岛


 1.方法一
  思路：
    从第一排起从第一个开始遍历
    当遇到1 把他所有的上下左右能相连的全部感染成2
    然后接着上面的地方在镜像查询 和上面的过程一样
    感染几次就有几个岛


public class DaoQuestion {
    public static void main(String[] args) {
        DaoQuestion dq=new DaoQuestion();
    byte martix[][]={
            {0,0,1,0,1,0,},
            {1,1,1,0,1,0,},
            {1,0,0,1,0,0,},
            {0,0,0,0,0,0,},
    };
        for (int i = 0; i < martix.length; i++) {
        System.out.println(Arrays.toString(martix[i]));
    }
        System.out.println(dq.defaultSolu(martix));
        System.out.println("=========================");
        for (int i = 0; i < martix.length; i++) {
        System.out.println(Arrays.toString(martix[i]));
    }
}

    public int defaultSolu(byte[][] martix){
        int v=0;
        for (int h = 0; h < martix.length; h++) {//行列
            for (int l = 0; l < martix[0].length; l++) {
                if (martix[h][l]==1){
                    v++;
                    //进行修改
                    _edit(martix,new  Martix(h,l));
                }
            }
        }
        return v;
    }
class  Martix{
    int h;

    public Martix(int h, int l) {
        this.h = h;
        this.l = l;
    }

    int l;

}
    private void  _edit(byte[][] martixs,Martix martix){
        Stack<Martix> stack =new Stack<Martix>();
        stack.push(martix);
        while (!stack.isEmpty()){
            Martix pop = stack.pop();
            martixs[pop.h][pop.l]=2;
            if (pop.l-1>=0 &&martixs[pop.h][pop.l-1]==1){
                stack.push(new Martix(pop.h,pop.l-1));
            }
            if (pop.l+1<martixs[0].length &&martixs[pop.h][pop.l+1]==1){
                stack.push(new Martix(pop.h,pop.l+1));
            }
            if (pop.h+1<martixs.length&&martixs[pop.h+1][pop.l]==1){
                stack.push(new Martix(pop.h+1,pop.l));
            }
        }
    }
}







1.并查集结构(效率非常高支持集合合并)
   search 0(1)
   union 0(1)

但是传统的数据结构做集合就效率就不是很好
   链表
     search >0(1)
     union 0(1)
   hash 表
     search 0(1)
     union> 0(1)

  并查集结构 图的方式
  

  并查集实现

public class CheckAndASet<E> {
    public CheckAndASet head;
    public int itemCount;
    private E _val;

    public CheckAndASet(E v) {
        this._val = v;
        init();
    }

    public CheckAndASet() {
        this._val = null;
        init();
    }

    public static void union(CheckAndASet s1, CheckAndASet s2) {
          if (CheckAndASet.isSameSet(s1,s2)) return;//已经是一个集合
          if (s1.itemCount>=s2.itemCount){
              s2.head=s1;
              s1.itemCount+= s1.itemCount;
              return;
          }
        s1.head=s2;
        s2.itemCount+=s1.itemCount;
    }
    /*
     * 是否是同一个集合
     * */
    public static boolean isSameSet(CheckAndASet s1, CheckAndASet s2) {
        if (s1 == null || s2 == null) return false;
        Stack<CheckAndASet> stacka =new Stack<>();
        Stack<CheckAndASet> stackb =new Stack<>();
        CheckAndASet head1 = s1.head;
        CheckAndASet head2 = s2.head;
        while (head1.head != head1 || head2.head != head1) {
            if (head1!=head1.head){
                head1 = head1.head;
                stacka.push(head1);
            }
            if (head2.head != head1){
                head2 = head2.head;
                stacka.push(head2);
            }
        }
        //优化(链过长对链进行扁平化操作)
        while (!stacka.isEmpty()){
            CheckAndASet pop = stacka.pop();
             pop.head=head1;
        }
        while (!stackb.isEmpty()){
            CheckAndASet pop = stackb.pop();
            pop.head=head2;
        }
        return head1 == head2;
    }

    private void init() {
        head = this;
        itemCount = 1;
    }

    public E get_val() {
        return _val;
    }

    public void set_val(E _val) {
        this._val = _val;
    }
}



进阶:如何设计一个并行算法

  2 核cpu 
  1.将一张大的举证按照例的一半分成两个
  2.每张举证分别扫苗到-- left张记录每个到最右边的边界若没到达边界则不记录
     right 记录左边的边界 不存在最左则不记录
     例 
       
       LEFT       RIGHT 
       A  b1      C b1
       B  b1      C b2
       B  b2      D b1
       A  b2      D b2
     在用并查集 设置 A   B  C  D 四个集合
     若边界相邻则 把他们集合合并 并且  totalcount-1

     当我们比较边界不是相邻或者 两个点在同一个集合则不用管了




  多核cpu 我们可以把一张大的集合划分为多个块计算每个块岛的数量在依次计算每个块的 上  下  左  右的 边界  在把每张表依次合并 最终就能计算出一张大的表岛的数量
```


## KMP 
```java
kmp 算法
    str1 ..............a........
    str2 ..............b........
   假设b的前缀相同是2
    str1开始 重  i 开始 遍历比较(和 str2 从0开始比较)  比较到 a 和b 不同查询前缀表 b前面的 前后相同为2
    str2 所以把位置移动到 b索引-2的位置上开始遍历

    为什么不在[i,aindex-2]之间找个位置呢？？ 
    
     假设可以 [i,aindex-2]  之间找到一个k

    str1 ........(k...(aindex-2).)a........
    str2 ........(......)b........   
    () () 之间根据遍历判断是相等的

    我们可以反着想  建设str2 和 str1 重k位置能匹配成功  那么  str2开头 (......)要和我们找的k 到a-1的元素要一样
    我们数一下 他们相同前缀这样就变成了6 和我们前面求的前缀表的数字冲突
    得出结论只能从 aindex-2的地方开始重新遍历



kmp 的基础算法
public int getIndexOf(String source,String mapping){
        if (mapping.length()<1||source.length()<1||mapping.length()>source.length()) return -1;
        int s1=0,s2=0;//s1 sources index  s2 mapping index
        int[] nextArray = getBeforeArray();
        while (s1<source.length()&&s2<mapping.length()){
             if (source.charAt(s1)==source.charAt(s2)){//都相等的情况
                s1++;
                s2++;
             }else if (source.charAt(s1)!=source.charAt(s2)&&nextArray[s2]!=-1){
                    s2=nextArray[s2];//把不同的地方移到 s2 移动到  [前缀相同]+1 的位置    s1 不变  （s2-nextArray[s2]） 因为已经比较过了
             }else {
                 s1++;
             }
        }

        return  s2==mapping.length()?s1-s2:-1;
    }



nextArray 数组的计算


```

