复杂度
```
常数操作(和数据量没什么关系)
    1.arr[i]  数组的寻址
    2.+=x/ <<  >>



时间复杂度(估计的时间上的上线)
    1.求实这个算法每个常数的次数

    例 ax*x+bx+c (该算法常数次数的和)

      时间复杂度 去掉 bx+c 和 a系数(不要低阶向只要高阶向并且去掉高阶向的系数)
      剩下的就是时间复杂度 该事件复杂度就是O(x*x)

      
      O 代表的是瓶颈 
      为什么去掉低阶向 和系数
      因为 当 x非常大的时候 低阶向就会越来越不重要，是可以忽略不计算的。



 

 区分两个指标相同的算法流程
    都是o(n) 
    虽然说都是一样的时间复杂度 但是他们的时间常数向的时间有可能是不一样的
     比如 * 和 << >> 的操作 计算机底层运算有可能是不同的。


额外空间复杂度




异或运算
    1.相同0 不同1
    2.不进位相加

  性质
     1.0^N=N  N^N=0
     2.满足交换结合率

  a=甲
  b=已
  a=a^b 甲^已
  b=a^b 甲^已^已=甲^(已^已)=甲^0=甲
  a=a^b 甲^已^甲=0^已=已


这样交换的前提是他们两个变量在内存不是同一块区域(统一块区域直接就初始化为0) 不管怎样交换都为0




为什么^运算支持交换结合率

1010 1000
1101 0101
0101 0101

0010 1000

 总结  每一位对应的计算出来的值和先后计算的顺序没有一点关系
 只与个数有关 偶数0 奇数就等于原来的值





```


题1
```java
array 有两个奇数个的数和多个偶数个的数
    public static void   t2(int array[]){
        int num=0;//a^b
        for (int i = 0; i < array.length; i++) {
            num=num^array[i];
        }
        //a!=b
        int one=num&(~num+1);//求出 a |b 的最右侧的1
        int num2=0;//a|b
        for (int i = 0; i < array.length; i++) {
               int data=array[i];
               if ((one&data)==one){//偶数个的数  和 b or a
                    num2=num2^data;
               }
        }
        num=num2^num;//a^b^(a|b)==a|b
        System.out.println("v1:="+num);
        System.out.println("v2:="+num2);
    }


````



差值排序

```java
    public static void  insertSort(int array[]){
        for (int i = 0; i < array.length; i++) {
            for (int j = i; j>0; j--) {
                if (array[j]>=array[j-1])break;//大 或等退出
                if (array[j]<array[j-1]){//判断当前值和上一个比较
                    InsertSort.swap(array,j,j-1);
                }
            }
        }
    }
    //交换
    public  static  void swap(int array[],int i,int j){
            array[i]=array[i]^array[j];
            array[j]=array[i]^array[j];
            array[i]=array[i]^array[j];
    }


00 退出

01 保证 1索引对应的值大于 0 索引对应的值

012 .....依次保证下去



时间复杂度
    数据的状况的不同 时间的复杂度是不同的

    O(N*N) 估算时间复杂度的时候按照时间复杂度的最差情况进行统计





顺序数列


二分法的时间复杂度为log2N


大于等于某个数最左位置也能使用二分


二分方法使用
    1.取中，一定能够进行排除一边，这种题就能够进行二分

    
```