## 详解同排序和排序内容的总结



堆
```java
完全二叉树的定义:从左到右依次变满的数就叫做完全二叉树



heapsize :二叉树总共存在多少个节点
left 节点索引 2*i+1
right 节点的索引 2*i+2

parent (i-1)/2


堆：
    大根堆：每一颗子树的最大值就是它的头节点
    小根堆：每一刻子树的最小值是它的头节点


接口提供
1.给我数子 heapInsert
2.返回最大数并且移除最大数  heapify



插入数据操作(堆大端)
    public static void heapInsert(int arr[], int num) {
        int index = heapSize;
        arr[index] = num;
        heapSize++;
        while (arr[index] > arr[(index - 1) / 2]) {//判断节点上面的根是否比子节点大  大 就不管  小交换(堆大端)
            swap(arr, index, (index - 1) / 2);
            index = (index - 1) / 2;
    }
    

获取最大的的数据并且移除

    public static int heapify(int arr[]) throws Exception {
        if (heapSize==0) throw  new Exception("size ==0  no call  heapify method");
        int index=0;
        int max = arr[0];
        arr[0]=arr[heapSize-1];
        heapSize--;
        while (index*2+1<heapSize&&index*2+2<heapSize){
            if (arr[index*2+1]>=arr[index*2+2]){
                    swap(arr,index,index*2+1);
                index=index*2+1;
            }else{
                swap(arr,index,index*2+2);
                index=index*2+2;
            }
        }
        if (index*2+1<heapSize&&arr[index*2+1]>arr[index]){
            swap(arr,index,index*2+1);
        }

        return  max;
    }


    public static void swap(int arr[], int i, int j) {
        if (i == j) return;
        arr[i] = arr[i] ^ arr[j];
        arr[j] = arr[i] ^ arr[j];
        arr[i] = arr[i] ^ arr[j];
    }


   



堆 排序(堆 ：又叫做优先级队列)

public class HeapSort {
    private static int heapSize = 0;

    public static void main(String[] args) throws Exception {
        int arr[] = {1, 2, 3, 4, 0, -1,100,28,0,22};
        int[] process = process(arr);
        System.out.println("init array:"+arrayString(process));

    }

    public static int[]  process(int [] array) throws Exception {
        if (array.length<=1) return  array;
        int[] newArray = createHeap(array);
        while (heapSize>0){
            int heapify = heapify(newArray);
            newArray[heapSize]=heapify;
        }
        return newArray;
    }
    public static   String arrayString(int [] array){
        if ((array.length)==0) return "[ ]";
        String str="[";
        for (int i = 0; i < array.length; i++) {
            str=(i==array.length-1)?str+array[i]+"]":str+array[i]+",";
        }
        return  str;
    }

    public static int[] createHeap(int arr[]) {
        int cloneArray[] = new int[arr.length];
        for (int i = 0; i < arr.length; i++) {
            heapInsert(cloneArray, arr[i]);
        }
        return cloneArray;
    }


    public static void heapInsert(int arr[], int num) {
        int index = heapSize;   
        arr[index] = num;
        heapSize++;
        while (arr[index] > arr[(index - 1) / 2]) {//判断节点上面的根是否比子节点大  大 就不管  小交换(堆大端)
            swap(arr, index, (index - 1) / 2);
            index = (index - 1) / 2;
        }
    }

    public static void swap(int arr[], int i, int j) {
        if (i == j) return;
        arr[i] = arr[i] ^ arr[j];
        arr[j] = arr[i] ^ arr[j];
        arr[i] = arr[i] ^ arr[j];
    }

    public static int heapify(int arr[]) throws Exception {
        if (heapSize==0) throw  new Exception("size ==0  no call  heapify method");
        int index=0;
        int max = arr[0];
        arr[0]=arr[heapSize-1];
        heapSize--;
        while (index*2+1<heapSize&&index*2+2<heapSize){
            if (arr[index*2+1]>=arr[index*2+2]){
                    swap(arr,index,index*2+1);
                index=index*2+1;
            }else{
                swap(arr,index,index*2+2);
                index=index*2+2;
            }
        }
        if (index*2+1<heapSize&&arr[index*2+1]>arr[index]){
            swap(arr,index,index*2+1);
        }

        return  max;
    }
}



先取出 arr[0] 一定是最大
在把数组的最后一个和第一个进行交换   heapSize --；
上面一步把最大的确定 并且把他排到最后 heapSize--就是让我们执行 heapify操作的时候不会进行操作最大的操作

把 最后的数到前面并且 执行 heapify 把 arr[0]求出堆大端 在重复执行上面的操作

这样 从小到大的数就这样确定下来了

时间复杂度 O(N*logN)

空间复杂度 O(1)


比较器
    Comparator
    实现上面 Comparator的接口

    重写 int compare(T o1, T o2);方法

升序
o1-o2 < 0  01在前面
o1-o2>0  o2在前面
== 随便那个在前面

降序
和升序的操作相反


```


