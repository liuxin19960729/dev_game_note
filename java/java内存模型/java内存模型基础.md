#### 概念
```
线程如何通信？？？

    共享内存的并发模型(java采用的类型)
        线程共享内存的公共状态 ，通过读写内存里面的公共状态进行隐式的通信


    消息传递的并发模型 
        因为没有共享程序，所以只能线程之间发送消息显示的进行通讯    

线程之间如果同步(并发执行)???
    同步：用于控制不同线程间发生的相对顺序。

```


#### java内存模型的抽象结构


```
java中实例，静态 ，数组元素 都存储在堆里面


堆内存在线程之间是共享的


局部变量 和 形参 和 异常处理的参数 存在 栈里面 他们在线程之间是不共享的


java线程之间的通信是由java内存模型决定的(JMM)


JMM决定一个线程的写入对另一个线程何时可见  线程之间的共享存储在主内存中(Main Memory)


每个线程都有一个私有的本地内存，读写内存存储着线程以读写内存变量的副本（本地内存是JMM的一个抽象的概念）
    本地内存：缓存，写缓存，寄存器和其他硬件和编译器的优化




```

![](./img/java内存模型图1.png)

```
由上图可以知道每个线程存在一个相同的共享内存模型

    两个线程之间的通信过程
            A 的的内存写入新数据--->把A的数据刷新到主内存里面

            B 线程到主内存里面读取A已经更新的数据并且把它写到 自己的副本上



总结 上面可知 JMM 模型中 两个线程之间的通信实际上是经过 主内存 这个介质进行线程之间的数据传递(来保证数据之间的可见性)

```


#### 从源代码到指令序列的重排序
```
为什么要进行指令的重排序???
   为了提高性能，编译器对指令的优化


重排序分为3类
    1.编译器优化的重排序：在不改变语义的情况下，编译器重新安排语句的执行的顺序。
    2.指令级并行的重排序：（现代的处理器允许指令的并行技术--将多条重叠执行）若不存在数据的依赖处理器将改变语句对应的机器码执行的顺序

    3.内存系统的重排序：处理器使用缓存 （对缓冲区的读写），（使得加载和存储的操作看上去是乱序的）



```

![](./img/源代码到执行指令的执行的过程.png)
```

上面的这些重排序操作可能会对内存的可见性造成影响

jmm编译器 的重排序 有一些特定的类型是不允许重排序的

jmm 处理器的重排序 java编译器在生成字节码序列的时候，插入特定类型的内存屏障(intel 里面是 memory fence 指令)
    插入这些内存屏障：禁止这些特定的类型的处理器进行重排序



jmm 属于语言级别的内存模型，他能确保在不同的处理器和编译器至间为程序员提供统一的保证性


```


#### 并发编程模型的分类

```
cpu缓存的优点
现代处理器写缓存【临时】保存写入数据,写缓存保证指令流水线的持续运行(避免由于处理器停顿下来等待写入内存数据产生的延迟)，同时通过【批处理的方式】刷新写缓冲区，合并写缓冲对同一地址的多次写，(减少内存访问对总线的占用次数)

cpu缓存的缺点
    写缓存值对当前cpu是可见的。(会对内存的操作执行的顺序产生影响)
       因为cpu对内存的读写顺序，不一定和实际的内存顺序一致（cpu缓存造成的原因）



```
![](./img/缓存写入_处理器指令顺序改变.png)
```
A B 线程 分别读取

我们指令的顺序为 A1-A2-A3

A1 缓存的写入并没有写入内存  
A1-A2 执行顺序 在cpu中可能 A2(读取内存)-1A

```

常见处理器重排序的规则
![常见处理器重排序的规则](./img/处理器重排序的规则.png)
```
上图

N:表示不允许两个操作重排序
Y:表示允许


所有的处理器都允许 Store-load 进行重排序
数据依赖：所有cpu都不允许重排序

上图的x86 包括 x64和amd64
```


### jMM 解决处理器的指令重排

```
为了保证内存的可见性java编译器生成指令顺序的时候会在适当的位置插入内存屏障指令禁止特定类型的处理器重排序

JMM把屏障指令分为4类
```
![](./img/内存屏障表.png)

```

最后的StoreLoad Barriers 全能型屏障，同时具有上面三个屏障的效果(现代处理器大多支持该屏障)--其他的屏障不是每个处理器都是支持的。

Store-Load 屏障的开销非常的大(他会把写如缓存的全部数据-->全部刷入到内存)

```


#### happens-before简介
```
jsr-33 java mm 

两个线程之间内存可见必须存在 happens-before关系


happens-before 仅仅要求前一个操作对后一个操作是可见的



```

Happens-before和JMM的关系

![Happens-before和JMM的关系](./img/happen_before_和_jmm的关系.png)






#### 重排序
```
编译器和处理器为了优化程序性能而对指令进行重排序的一种手段
```


#### 数据依赖性

```
定义：两个对同一个变量的操作，并且两个操作中有一个未写操作，那么这两个操作之间存在着数据的依赖性

```

数据依赖性的情况

![数据依赖型](./img/数据依赖型表.png)
```
    上面三种情况只要进行重排序，数据的结果就会发生改变

处理器和编译器都有可能对操作进行重排序，他们会遵循数据的依赖性(他们不会改变数据性关系)
也就是说有上面图片的三种关系的一种就不会进行重排序(只针对单个线程)


```


#### as-if-serial 

```
as-if-serial :编译器和处理器不管怎样重排序都不能改变最终的结果



double pi = 3.14; // A 读
double r = 1.0; // B  读
double area = pi * r * r; // C  写


A-C  B-C  写读 是有依赖关系的

A-B  不存在依赖关系 因为不是对同一个变量进行操作


所以有两种方式进行重排序

A-B-C

B-A-C



这种重排序的问题在单线程程序中不受影响的
```





#### 程序的顺序规则
```
double pi = 3.14; // A 读
double r = 1.0; // B  读
double area = pi * r * r; // C  写

这程序有三个 happens-before规则

A happens-before B
B happens-before C
A happens-before C


注意： cpu 和编译器不会对有依赖关系的指令进行重排序


根据重排 B 有可能 在A之前 执行  
但是 A happens-before B 并不要求 A 执行先于B 而是 A的结果对B可见

A-B B-A jmm认为这种排序并不违法 允许这种排序

```



#### 重排序对多线程的影响
```java
class ReorderExample {
    int a = 0;
    boolean flag = false;
    public void writer() {
        a = 1; // 1
        flag = true; // 2
    }
    Public void reader() {
        if (flag) { // 3
        int i = a * a; // 4
        ……
        }
    }
}


A和B两个线程 分别执行程序  A-->writer()

随后  B-->render() 方法
      B线程在执行 render()的时候能否看到 a=1



B 不一定看到 a=1
   1,2两个操作没有依赖关系(不是对两个相同参数进行操作和没有包含一个写) 编译器和处理器可能进行重排序  2可能先执行与1


```

上面程序重排序可能造成的错误 1 2重排序错误
![重排序的错误1](./img/重排序的错误1.png)
//上面的虚线表示错误的读操作



<br>

34 重排序错误

![34 重排序错误](./img/重排序错误2.png)

```

上图若34 出现重排序



当代中存控制依赖性时，会影响执行的并行度，编译器和处理器会采取猜测(预估)来克服相关性并行度的影响。

当执行线程B时候可以提前先读取并计算 a*a,然后把结果临时保存到重排缓冲（rob）中 当3的条件为真 就世界吧值写入i中




单线程 遵守 as-if-serial 允许重排序 最终结果不影响，多线程允许重排就会改变程序的执行结果


```


#### 顺序一致性


