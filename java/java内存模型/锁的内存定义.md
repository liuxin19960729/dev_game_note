#### 锁的释放-获取建立的happen-before关系
```

锁的作用：
    临界区互相排斥
    释放锁的线程向获取锁的线程发送信息


```


#### 锁的释放和获取内存的语义
```
线程锁释放的时候，jmm会把本地内存的共享变量刷新到主内存里面去

这样对其他的线程就可见了










```
### CAS 如何具有volatile读和写的的内存语义

```c++
inline jint Atomic::cmpxchg (jint exchange_value, volatile jint* dest,
jint compare_value) {
// alternative for InterlockedCompareExchange
    int mp = os::is_MP();
        __asm {
        mov edx, dest
        mov ecx, exchange_value
        mov eax, compare_value
        LOCK_IF_MP(mp)
        cmpxchg dword ptr [edx], ecx
        }
}


LOCK_IF_MP(mp)  判断是否是 多处理器
 是 lock 指令

 否 不添加  单处理器本省是具有维护处理器内的顺序一致性的



### lock指令
   以前lock指令是总线锁  （锁住总线开销很大）

   现在intel 添加了缓存锁  保证命令执行的原子性，降低开销

   缓存锁：
        禁止该指令，与之前和之后的读和写指令重排序
        把写缓冲区中的所有数据刷新到内存中


    上面的缓存锁的语义和volatile 添加屏障的语义屏障的语义是一样的




总线事务只能允许一个线程操作(读写)

```



#### concurrent包的实现

```

```