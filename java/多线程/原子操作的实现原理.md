#### 处理器如何实现原子操作
```
原子性 atomic 不能分割，不能被中断的一个或一系列操作

两种方式实现多处理器之间的原子操作
    1.缓存加锁
    2.总线加锁

1.保证基本内存操作的原子性
  首先保证 内存-读|写 如一个字节是原子的

  奔腾6和现在最新的处理器能自动保证单处理器对同一缓存里进行16/32/64位的操作(读写)是原子的(也就是说每个操作在当前这个处理器里面不会被切换中断，只能被这个操作执行完或者还未执行才能才能被中断或切换)



处理器本省复杂的内存操作(跨多级缓存访问，跨多页操作缓存....)是不保证原子性的

处理器提供了总线锁定和缓存锁定两种机制来保证复杂内存操作的原子性


```



#### 总线锁定保证原子性

```
在多和处理器中
若 i 是共享的参数
对共享内存 i参数进行 i++操作

```
![](./img/atomic_总线锁_1.png)


```
有上图可知本来在我们期望的值是3
但是最终的结果却是2


造成这个的原因可能
    在多个cpu中 每个cpu有各自的缓存(L1,L2 不进行共享)
    他门分别从内存(或者L3缓存 这个缓存是共享缓存)里面那数据然后放进的缓存(这时他们获取的值都是一样的) 他们当指令  mov ax,xxx 的时候是到自己的缓存里面拿取（两个核心都是拿自己缓存里面的值）然后在 add 操作
    在 mov [],ax写进去 这就是为什么这两个线程都写的是2


但是使用了cpu 提供的总线的锁之后 lock # 信号
其他cpu的请求将会被阻塞，当前线程独享内存


```


#### 使用缓存锁来保证原子性
```
我们只需要保证对某个内存地址的操作是原子性即可。


本质：：：： [他是把cpu和内存之间的通信锁住]

相比于总线锁的把总线锁住让其他cpu在锁定期间不能操作任意的内存地址来说开销要小很多


目前处理器在某些场合使用缓存锁来代替总线锁



频繁使用的内存会被缓存到 L1 L2 L3里面

缓存锁:内存区域如果被缓存在处理器的缓存中 并且在lock 期间被锁定 ，那么当他执行写入内存的操作时，处理器【不】在总线上声言#LOCK信号，而是修改内部的内存地址，并允许他使用缓存一致性保存原子性，
【缓存一致性的机制会阻止同时修改两个以上的处理器的缓存的内存区域】当其他处理器会写以被锁定的缓存行的数据是，会使缓存行无效，(你要使用该地址的数据会重新到内存里面拿取并且把值放进缓存并且在使用)

```

#### 有两种情况处理器不会使用缓存锁定

```
1.操作的数据不再缓存里面(要访问数据直接到内存里面获取)，或操作的数据跨多个缓存行(cache line)


2.处理器本来不知处缓存锁定


缓存锁定和总线锁定都是使用  lock 汇编指令来实现

```


## java如何实现原子操作

```java
锁或cas 操作来实现原子操作


### cas 实现原子操作的三大问题
    1.ABA 问题
    2.循环长，开销大
    3.只能保证一个共享变量的原子操作


1.ABA:
   lock comxchg xxxx,xxx
   xxxx /r/m   xxx m  
   若xxxx 和 xxx的值相同 则交换

   前面有lock 指令 可能是缓存锁定 也可能是总线锁定

    第一个线程 A->B
    第二个线程 B->A 

    第三个线程 拿到的值为A 在他看来值是没有改变的，但是确实改变了的

解决方法 对值添加一个版本高 每更新一次+1  1A->2B->3A

JDK1.5提供了一个 AtomicStampedRreference 来解决ABA的问题

AtomicStampedRreference类的
compareAndSet方法就是检查当前的引用是否等于预期的引用，并且检查标志是否等于预期的标志

若两个都相等则把他们全部设为给定的更新值



public boolean compareAndSet(
    V expectedReference, // 预期引用
    V newReference, // 更新后的引用
    int expectedStamp, // 预期标志
    int newStamp // 更新后的标志
)


2.循环时间长，开销大
    cas长时间不成功消耗较大，会给 cpu带来较大的开销。

    若cpu支持pause指令那么效率会有一定的提升
            pause 指令
                1.延长流水线执行(不会过多的消耗执行资源)
                2.避免在退出循环的时候因为内存顺序冲突而引起cpu流水线的清空,从而题号cpu执行效率

3.只能保证一个共享变量的原子操作
          jdk1.5支持对对象之间的原子性 AtomicReference
          我们可以把多个变量放在一个对象里面

```


#### 使用锁机制来实现原子操作

```
    只有获得了锁，才能够操作锁定的内存区域
```