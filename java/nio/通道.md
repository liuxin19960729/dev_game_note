# 通道
```
通道处于的位置关系:
字节缓冲区-->  Channel -->文件/套加字 
文件/套加字-->  Channel -->字节缓冲区

Channel 就好比是一个数据(缓冲区)和实体之间通信的通道


定义：channel是一种途径，我们借助该途径能用最小的开销来访问Os IO的服务

         JVM: ByteBuffer --channel-->OS filesystem network




```


###  Channel.java

```java
public interface Channel extends Closeable {
    public boolean isOpen();
    public void close() throws IOException;

}

public interface InterruptibleChannel
    extends Channel
{
   //中断通道  
    public void close() throws IOException;
}





public interface ReadableByteChannel extends Channel {

    public int read(ByteBuffer dst) throws IOException;

}


public interface WritableByteChannel
    extends Channel
{
    public int write(ByteBuffer src) throws IOException;

}

WritableByteChannel
ReadableByteChannel 
这两个接口就说明通道上只能使用字节缓冲区
OS io 接口是用字节的形式实现的






AbstractSelectableChannel
为选择提供常用的方法
AbstractInterruptibleChannel
为中端提供常用的方法


```

### 使用通道
```java
ByteChannel

public interface ByteChannel
    extends ReadableByteChannel, WritableByteChannel
{

}

ByteChannel 实现双向的的通道 既能read(ByteBuffer dst) 也能
write(ByteBuffer src)




注意
        FileInputStream fis =new FileInputStream("");
        FileChannel channel = fis.getChannel();

   由于该文件的权限只读
   当我们使用 chennel.write() //throw NonWritableChannelException



read() 和 write()
返回的值是已经传输的字节数
会影响ByteBuffer 里面的position的值(为什么？？)
如果只传输了部分下一次可以接着上一次传输的地方进行传输

```

### 关闭通道
```java
注意:通道不能进行重复的使用
通道代表一个特定的服务的特定的连接
通道关闭 连接丢失




public interface Channel extends Closeable {
    public boolean isOpen();
    public void close() throws IOException;

}



不管是阻塞和是未阻塞的通道模式
调用close()方法的时候
    关闭底层服务的时候可能会导致线程占时阻塞


线程1-->close()
线程2 ----阻塞---->close()
线程3--------阻塞------------>close();

一个线程调用close(),会导致其他调用close()方法会阻塞

channel 关闭 执行 write() or read() 会抛出CloseChannelException的方法





线程 被通道阻塞并且同时中断 
通道将被关闭  线程产生一个ClosedByInterruptException 的异常



其实也就是说放我们在一个线程里面调用Channel 造成阻塞的时候 我们在另一个线程   thread.interrupt(); 调用这个方法的时候，这样

会关闭当前管道然后抛出异常 java.nio.channels.ClosedByInterruptException 



一个通道被关闭休眠在该通道的所有线程接收到 AsynchronousCloseException 接着通道关闭 不在可用(为了唤醒被该通道阻塞的线程)

```



## 文件通道
```
1.文件通道只能是阻塞的


FileChannel 不能直接创建
    通过 RandomAccessFile FileInputStream FileOutPutStream 上调用getChannel 获取

    fiLeChannel 权限和file文件有相同的访问权限




FileChannel 线程安全    
jvm 保证同一个进程的多个线程保证看到的通一个文件都是一致的.



一个jvm 进程看到的文件 和其他进程看到的文件可能一致(一般来说是一致的) 也可能不一致 。
    多进程并发访问外部文件取决于操作系统和文件系统的管理



```

### 访问文件
```java

position
  决定文件那一处被写或者被读

long position(); 返回的是当前文件pos值
void position(long newPosition)
     newPosition <0  throw IllegalArgumentException
 当 newPosition超出结尾 不会报错 

read() 检查到position 位置超过 返回文件结束符



例 FileChannel 和 ByteBuffer的简单运用


    RandomAccessFile fas=new RandomAccessFile(file,"rw");
        FileChannel channel = fas.getChannel();
        ByteBuffer byteBuffer =ByteBuffer.allocate(100);
        String str="";
        channel.read(byteBuffer);
        while (byteBuffer.position()!=0){
            byte[] array = byteBuffer.array();
            str+=new String(array,0,byteBuffer.position());
            byteBuffer.clear();
            channel.read(byteBuffer);
        }
        fas.close();
        System.out.println(str);


RandomAccessFile
fas.seek(100);  设置Position的位置

FileChannel
channel.position(100); //channel 既能获取position位置也能设置




int read() 
  每次执行之后read()会position自动的更新
  返回值为读取文件大小
  position 到达文件结尾 在执行read() 会返回 -1文件结尾

public abstract long size() throws IOException;
当前文件的大小

当 position >size wirite写入的就是新东西

例:
        String file = Test1.class.getClassLoader().getResource("static/index.html").getFile();
//        System.out.println(file);
        RandomAccessFile fas=new RandomAccessFile(file,"rw");
        FileChannel channel = fas.getChannel();
        ByteBuffer byteBuffer =ByteBuffer.allocate(200);
        channel.position(channel.size());把位文件操作的位置放入到结尾
        byteBuffer.put("刘鑫".getBytes("utf-8"));
        byteBuffer.flip();
        channel.write(byteBuffer);
        fas.close();







超出size的地方都会消失
channel.truncate((channel.size()-50));

注意 size 是重pos 0开始计算 和position的位置没有关系

当position>size执行文件 1.会删除[0,size] 外的内容 position 会变成 size 的值指向当前文件最后


在现代的操作系统中对磁盘的写不会立即写入到磁盘 ，会先进行缓存，和磁盘的延迟写入 这样做为了提高性能

channel.force(true);
   true 在方法返回前原数据(文件所有者 访问权限 最后一次修改时间 等)是更新到磁盘

  false 同步文件数据的更改和磁盘进行同步

  注意 ：建议 false 元数据对数据恢复其实没有什么帮助 还会造成os底层至少一个Io操作的消耗

   保证通道创建(或上一force之后)的数据全部同步到磁盘

   运用场景 事务 保证数据的完整和可靠的恢复


注意:在有的os中jvm没有实现对文件系统的强制同步磁盘的操作

```


### 文件锁定
```
共享文件锁 ：依赖我们使用的OS(不是所有的os都是支持的)

os 不支持共享锁 ，我们在对共享锁进行请求的时候会自动提升为[独占锁]  保证了准确性  但是性能却严重的影响了
  




FileChannel 文件锁模型

锁关联的是文件 
   对同一台JVM上的其他线程不上锁
   对其他进程 来上锁


    public final FileLock lock() throws IOException {
        return lock(0L, Long.MAX_VALUE, false);
    }


      public abstract FileLock lock(long position, long size, boolean shared)
        throws IOException;


锁定文件的区域 position size 

boolean shared  
true 共享锁
   一定打开read权限  也可以打开写
false 独占锁
   一定打开write权限 也可以读


当执行写的时候我们不光可以size大小是文件的大小
可以超出 这样写的数据就能够是文件增加新的内容


注意 当我们写文件时申请锁给了一个范围 ，当我写之后超出了范围 ，超出的范围的地方是不受锁保护的。



public final FileLock lock() throws IOException {
        return lock(0L, Long.MAX_VALUE, false);
}

调用不带参数的锁是独占锁  范围 Long.MAX_VALUE



FileLock lock()  没有获得锁阻塞
FileLock tryLock() 没有获得锁返回null


//锁的创建 开启
FileLock lock = channel.lock();//独占锁
lock.release();//释放锁
或者jvm关闭的时候锁也会失效


isValid()锁是否有效
isShared() 是否是共享锁(os 不支持共享锁永远返货false)

给定一个位置 查看区域是否与锁的区域重叠
boolean overlaps(long position, long size); 


我们判断了所有锁的区域都返回false也不能保证一定能取得到锁，我们不仅和jvm线程竞争我们还与其他外部的进程竞争锁

可以使用tryLock()确认一些是否能获取到锁


注意：一定在出现错误或者用完之后对锁进行释放 ，避免造成对其他进程或线程的死锁

```

## 内存映射文件
```
FileChannel 

    public abstract MappedByteBuffer map(MapMode mode,
                                         long position, long size)
        throws IOException;


MappedByteBuffer 数据是在磁盘中的

MappedByteBuffer map = channel.map();
map.get()
从磁盘中获取数据

put() 会写到文件 我的写对其他进程的阅读者可见

读取到的数据直接缓存到系统缓存 不是缓存到jvm ,我们拿取直接通过映射找到对应的位置

当文件缓存到系统页的时候，我们访问的就是直接对该系统缓存的老获取


文件锁+映射 

position
size
通过上面的消息位置 大小 的文件内容缓存到内存

MappedByteBuffer map = channel.map(FileChannel.MapMode.READ_ONLY, 100, 150);

把文件[100,250)位置的数据缓存到读取 并且缓存到系统的缓存中

注意 map 的size和锁不一样 不能超过实际文件的大小 (size 过大会浪费内存) 也可能会抛出IoException


      public static final MapMode READ_ONLY
            = new MapMode("READ_ONLY");

        /**
         * Mode for a read/write mapping.
         */
        public static final MapMode READ_WRITE
            = new MapMode("READ_WRITE");

        /**
         * Mode for a private (copy-on-write) mapping.
         */
        public static final MapMode PRIVATE
            = new MapMode("PRIVATE");



PRIVATE (copy -on-write) 写时拷贝操作
MappedByteBuffer 对象
        MappedByteBuffer map = channel.map(FileChannel.MapMode.PRIVATE, 0, channel.size());

        map.put()
put() 的时候 会对内存修改不会对disk内容修改


```


