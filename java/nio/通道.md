# 通道
```
通道处于的位置关系:
字节缓冲区-->  Channel -->文件/套加字 
文件/套加字-->  Channel -->字节缓冲区

Channel 就好比是一个数据(缓冲区)和实体之间通信的通道


定义：channel是一种途径，我们借助该途径能用最小的开销来访问Os IO的服务

         JVM: ByteBuffer --channel-->OS filesystem network




```


###  Channel.java

```java
public interface Channel extends Closeable {
    public boolean isOpen();
    public void close() throws IOException;

}

public interface InterruptibleChannel
    extends Channel
{
   //中断通道  
    public void close() throws IOException;
}





public interface ReadableByteChannel extends Channel {

    public int read(ByteBuffer dst) throws IOException;

}


public interface WritableByteChannel
    extends Channel
{
    public int write(ByteBuffer src) throws IOException;

}

WritableByteChannel
ReadableByteChannel 
这两个接口就说明通道上只能使用字节缓冲区
OS io 接口是用字节的形式实现的






AbstractSelectableChannel
为选择提供常用的方法
AbstractInterruptibleChannel
为中端提供常用的方法


```

### 使用通道
```java
ByteChannel

public interface ByteChannel
    extends ReadableByteChannel, WritableByteChannel
{

}

ByteChannel 实现双向的的通道 既能read(ByteBuffer dst) 也能
write(ByteBuffer src)




注意
        FileInputStream fis =new FileInputStream("");
        FileChannel channel = fis.getChannel();

   由于该文件的权限只读
   当我们使用 chennel.write() //throw NonWritableChannelException



read() 和 write()
返回的值是已经传输的字节数
会影响ByteBuffer 里面的position的值(为什么？？)
如果只传输了部分下一次可以接着上一次传输的地方进行传输

```

### 关闭通道
```java
注意:通道不能进行重复的使用
通道代表一个特定的服务的特定的连接
通道关闭 连接丢失




public interface Channel extends Closeable {
    public boolean isOpen();
    public void close() throws IOException;

}



不管是阻塞和是未阻塞的通道模式
调用close()方法的时候
    关闭底层服务的时候可能会导致线程占时阻塞


线程1-->close()
线程2 ----阻塞---->close()
线程3--------阻塞------------>close();

一个线程调用close(),会导致其他调用close()方法会阻塞

channel 关闭 执行 write() or read() 会抛出CloseChannelException的方法





线程 被通道阻塞并且同时中断 
通道将被关闭  线程产生一个ClosedByInterruptException 的异常



其实也就是说放我们在一个线程里面调用Channel 造成阻塞的时候 我们在另一个线程   thread.interrupt(); 调用这个方法的时候，这样

会关闭当前管道然后抛出异常 java.nio.channels.ClosedByInterruptException 



一个通道被关闭休眠在该通道的所有线程接收到 AsynchronousCloseException 接着通道关闭 不在可用(为了唤醒被该通道阻塞的线程)

```