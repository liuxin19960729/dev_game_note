# 通道
```
通道处于的位置关系:
字节缓冲区-->  Channel -->文件/套加字 
文件/套加字-->  Channel -->字节缓冲区

Channel 就好比是一个数据(缓冲区)和实体之间通信的通道


定义：channel是一种途径，我们借助该途径能用最小的开销来访问Os IO的服务

         JVM: ByteBuffer --channel-->OS filesystem network




```


###  Channel.java

```java
public interface Channel extends Closeable {
    public boolean isOpen();
    public void close() throws IOException;

}

public interface InterruptibleChannel
    extends Channel
{
   //中断通道  
    public void close() throws IOException;
}





public interface ReadableByteChannel extends Channel {

    public int read(ByteBuffer dst) throws IOException;

}


public interface WritableByteChannel
    extends Channel
{
    public int write(ByteBuffer src) throws IOException;

}

WritableByteChannel
ReadableByteChannel 
这两个接口就说明通道上只能使用字节缓冲区
OS io 接口是用字节的形式实现的






AbstractSelectableChannel
为选择提供常用的方法
AbstractInterruptibleChannel
为中端提供常用的方法


```

### 使用通道
```java
ByteChannel

public interface ByteChannel
    extends ReadableByteChannel, WritableByteChannel
{

}

ByteChannel 实现双向的的通道 既能read(ByteBuffer dst) 也能
write(ByteBuffer src)




注意
        FileInputStream fis =new FileInputStream("");
        FileChannel channel = fis.getChannel();

   由于该文件的权限只读
   当我们使用 chennel.write() //throw NonWritableChannelException



read() 和 write()
返回的值是已经传输的字节数
会影响ByteBuffer 里面的position的值(为什么？？)
如果只传输了部分下一次可以接着上一次传输的地方进行传输

```

### 关闭通道
```java
注意:通道不能进行重复的使用
通道代表一个特定的服务的特定的连接
通道关闭 连接丢失




public interface Channel extends Closeable {
    public boolean isOpen();
    public void close() throws IOException;

}



不管是阻塞和是未阻塞的通道模式
调用close()方法的时候
    关闭底层服务的时候可能会导致线程占时阻塞


线程1-->close()
线程2 ----阻塞---->close()
线程3--------阻塞------------>close();

一个线程调用close(),会导致其他调用close()方法会阻塞

channel 关闭 执行 write() or read() 会抛出CloseChannelException的方法





线程 被通道阻塞并且同时中断 
通道将被关闭  线程产生一个ClosedByInterruptException 的异常



其实也就是说放我们在一个线程里面调用Channel 造成阻塞的时候 我们在另一个线程   thread.interrupt(); 调用这个方法的时候，这样

会关闭当前管道然后抛出异常 java.nio.channels.ClosedByInterruptException 



一个通道被关闭休眠在该通道的所有线程接收到 AsynchronousCloseException 接着通道关闭 不在可用(为了唤醒被该通道阻塞的线程)

```



## 文件通道
```
1.文件通道只能是阻塞的


FileChannel 不能直接创建
    通过 RandomAccessFile FileInputStream FileOutPutStream 上调用getChannel 获取

    fiLeChannel 权限和file文件有相同的访问权限




FileChannel 线程安全    
jvm 保证同一个进程的多个线程保证看到的通一个文件都是一致的.



一个jvm 进程看到的文件 和其他进程看到的文件可能一致(一般来说是一致的) 也可能不一致 。
    多进程并发访问外部文件取决于操作系统和文件系统的管理



```

### 访问文件
```java

position
  决定文件那一处被写或者被读

long position(); 返回的是当前文件pos值
void position(long newPosition)
     newPosition <0  throw IllegalArgumentException
 当 newPosition超出结尾 不会报错 

read() 检查到position 位置超过 返回文件结束符



例 FileChannel 和 ByteBuffer的简单运用


    RandomAccessFile fas=new RandomAccessFile(file,"rw");
        FileChannel channel = fas.getChannel();
        ByteBuffer byteBuffer =ByteBuffer.allocate(100);
        String str="";
        channel.read(byteBuffer);
        while (byteBuffer.position()!=0){
            byte[] array = byteBuffer.array();
            str+=new String(array,0,byteBuffer.position());
            byteBuffer.clear();
            channel.read(byteBuffer);
        }
        fas.close();
        System.out.println(str);


RandomAccessFile
fas.seek(100);  设置Position的位置

FileChannel
channel.position(100); //channel 既能获取position位置也能设置




int read() 
  每次执行之后read()会position自动的更新
  返回值为读取文件大小
  position 到达文件结尾 在执行read() 会返回 -1文件结尾

public abstract long size() throws IOException;
当前文件的大小

当 position >size wirite写入的就是新东西

例:
        String file = Test1.class.getClassLoader().getResource("static/index.html").getFile();
//        System.out.println(file);
        RandomAccessFile fas=new RandomAccessFile(file,"rw");
        FileChannel channel = fas.getChannel();
        ByteBuffer byteBuffer =ByteBuffer.allocate(200);
        channel.position(channel.size());把位文件操作的位置放入到结尾
        byteBuffer.put("刘鑫".getBytes("utf-8"));
        byteBuffer.flip();
        channel.write(byteBuffer);
        fas.close();







超出size的地方都会消失
channel.truncate((channel.size()-50));

注意 size 是重pos 0开始计算 和position的位置没有关系

当position>size执行文件 1.会删除[0,size] 外的内容 position 会变成 size 的值指向当前文件最后


在现代的操作系统中对磁盘的写不会立即写入到磁盘 ，会先进行缓存，和磁盘的延迟写入 这样做为了提高性能

channel.force(true);
   true 在方法返回前原数据(文件所有者 访问权限 最后一次修改时间 等)是更新到磁盘

  false 同步文件数据的更改和磁盘进行同步

  注意 ：建议 false 元数据对数据恢复其实没有什么帮助 还会造成os底层至少一个Io操作的消耗

   保证通道创建(或上一force之后)的数据全部同步到磁盘

   运用场景 事务 保证数据的完整和可靠的恢复


注意:在有的os中jvm没有实现对文件系统的强制同步磁盘的操作

```


### 文件锁定
```
共享文件锁 ：依赖我们使用的OS(不是所有的os都是支持的)

os 不支持共享锁 ，我们在对共享锁进行请求的时候会自动提升为[独占锁]  保证了准确性  但是性能却严重的影响了
  




FileChannel 文件锁模型

锁关联的是文件 
   对同一台JVM上的其他线程不上锁
   对其他进程 来上锁


    public final FileLock lock() throws IOException {
        return lock(0L, Long.MAX_VALUE, false);
    }


      public abstract FileLock lock(long position, long size, boolean shared)
        throws IOException;


锁定文件的区域 position size 

boolean shared  
true 共享锁
   一定打开read权限  也可以打开写
false 独占锁
   一定打开write权限 也可以读


当执行写的时候我们不光可以size大小是文件的大小
可以超出 这样写的数据就能够是文件增加新的内容


注意 当我们写文件时申请锁给了一个范围 ，当我写之后超出了范围 ，超出的范围的地方是不受锁保护的。



public final FileLock lock() throws IOException {
        return lock(0L, Long.MAX_VALUE, false);
}

调用不带参数的锁是独占锁  范围 Long.MAX_VALUE



FileLock lock()  没有获得锁阻塞
FileLock tryLock() 没有获得锁返回null


//锁的创建 开启
FileLock lock = channel.lock();//独占锁
lock.release();//释放锁
或者jvm关闭的时候锁也会失效


isValid()锁是否有效
isShared() 是否是共享锁(os 不支持共享锁永远返货false)

给定一个位置 查看区域是否与锁的区域重叠
boolean overlaps(long position, long size); 


我们判断了所有锁的区域都返回false也不能保证一定能取得到锁，我们不仅和jvm线程竞争我们还与其他外部的进程竞争锁

可以使用tryLock()确认一些是否能获取到锁


注意：一定在出现错误或者用完之后对锁进行释放 ，避免造成对其他进程或线程的死锁

```

## 内存映射文件
```
FileChannel 

    public abstract MappedByteBuffer map(MapMode mode,
                                         long position, long size)
        throws IOException;


MappedByteBuffer 数据是在磁盘中的

MappedByteBuffer map = channel.map();
map.get()
从磁盘中获取数据

put() 会写到文件 我的写对其他进程的阅读者可见

读取到的数据直接缓存到系统缓存 不是缓存到jvm ,我们拿取直接通过映射找到对应的位置

当文件缓存到系统页的时候，我们访问的就是直接对该系统缓存的老获取


文件锁+映射 

position
size
通过上面的消息位置 大小 的文件内容缓存到内存

MappedByteBuffer map = channel.map(FileChannel.MapMode.READ_ONLY, 100, 150);

把文件[100,250)位置的数据缓存到读取 并且缓存到系统的缓存中

注意 map 的size和锁不一样 不能超过实际文件的大小 (size 过大会浪费内存) 也可能会抛出IoException


      public static final MapMode READ_ONLY
            = new MapMode("READ_ONLY");

        /**
         * Mode for a read/write mapping.
         */
        public static final MapMode READ_WRITE
            = new MapMode("READ_WRITE");

        /**
         * Mode for a private (copy-on-write) mapping.
         */
        public static final MapMode PRIVATE
            = new MapMode("PRIVATE");



PRIVATE (copy -on-write) 写时拷贝操作
MappedByteBuffer 对象
        MappedByteBuffer map = channel.map(FileChannel.MapMode.PRIVATE, 0, channel.size());

        map.put()


   map.isReadOnly() // 不是文件的是否只读的检查 是对映射的缓冲区是否只读的检查


FileChannel.MapMode.PRIVATE   copy-on-write 写时拷贝的映射
   执行put()方法修改buffer时 都会进行拷贝 ，拷贝的数据只有 MappedByteBuffer 实例可以看到
   对底层文件数据没有任何影响，（要求文件必须rw权限打开）

   运用场景

   进程1 MappedByteBuffer---------->映射
                                   buffer1
   进程2  MappedByteBuffer---------->映射

   写时拷贝 两个进程对buffer写时都是复制一分数据到自己进程的内存空间进行写，
   随意可以同时进行这种写的操作




当其他方式和MapMode.PRIVATE 修改到同一区域？？？？(怎么报正多线程 多进程用映射写拷贝多个映射对象数据的一致性)
    1.用其他方式对文件的修改   在 MapMode.PRIVATE  都能看到
    2.put()-->受影响的页(修改的地方)同步到copy缓存里面，
    3.***** 一旦某个也被拷贝 ，其他缓冲区不能对文件做更新--保证原子性





当文件变大 ？？
    文件 弹性 大小能改变
    映射区域大小是固定的
   
   当文件大小变化 映射的部分区域或全部区域就不能进行访问 ，并返回未定义的数据或抛出未检查的异常

  MappedByteBuffer 缓冲区域占用的内存区域是os层的不是jvm堆栈内存




我们创建好 MappedByteBuffer ，建立好映射之后，不会立即到disk里面读取数据把他读取到内存里面(行为和os有关)

创建Mapped的时候会传入 position size 两个参数 也就是说确定了读取文件的位置和读取的大小 ，但是不会立即读取

当我们需要访问数据的时候他才会到磁盘读取然后放入的os 缓存 有点像虚拟内存的 swap 内存和磁盘的交换原理

通过 MappedByteBuffer 这个 句柄read()访问文件 虚拟内存系统会根据你的需求把文件相应的数据读进来，将文件读取到内存需要一次或者多次的磁盘访问



load();
    加载整个文件进入到内存，并且常驻内存 
              通过文件系统内存页的映射关系 找到disk对应的文件块 把他读进到内存 
              并且会把不经常使用的内存挤出去
                 若挤出去的区域发生变化 则会同步到disk ,未发生变化 直接丢弃
              把disk区域的数据读到位置 然后和 进程 内存和 这块内存建立映射关系

   load()方法的执行代价非常的高  若文件非常大 可能造成大量的内存区域page in

   
   load() 主要作用：
        提前加载文件埋单，以便后续访问的速度尽可能的快

   预加载 并不能保证全部页 都在内存里面，不管怎样访问该Mapped文件句柄还是有可能也调入发生。他的内存内容能存活多久并不能受jvm控制。
   jvm 不支持永久存储内存的api  ,有些os api支持




isLoad()
  判断映射文件完全是常驻内存
  true 完全常驻内存
  false 该文件并未完全常驻  并不意味着访问他一定很慢 ，
  isLoad()并不是非常准确知识一个参考 因为 gc 异步 操作系统的内存情况是动态的


force()
      强制将映射缓冲区上的内容跟新到disk 

      注意 1.FileChannel.MapMode.READ_WRITE 只有这个模式有效？？？？？
           read_only  private 他对os缓冲区没有更改 所以执行force() 检查不出缓冲区有那些变化所有没有效
          
          2.当channel 调用映射的时候 使用 mapped 的 force

          不能使用channel 的force
```



## Socket通道

```
实现了非阻塞 
能通过设置经选择通道阻塞和非阻塞



为什么nio 要用一个或几个线程干礼来成百上千个活动连接？？？？
   
       以前的sokcet一个连接对应着一个线程 ，线程越多线程之间的来回切换上下文造成巨大的开销


DatagramChannel和SocketChannel实现定义读写

ServerSocketChannel 负责监听传入的连接和创建新的SocketChannel对象
   (ServerSocketChannel 是不进行传输数据的)


通道
DatagramChannel SocketChannel ServerSocketChannel

与之对应的socket

DatagramSocket    Socket      ServerSocket



Socket
    public SocketChannel getChannel() {
        return null;
    }

    返回通道永远是null
ServerSocket
  getChannel() 也返回是null
  


```



### 非阻塞模式
```
 public abstract SelectableChannel configureBlocking(boolean block)

 true 阻塞模式
 false 非阻塞模式


boolean isBlocking() 判断Socket 属于是那种模式



   public final Object blockingLock() {
        return regLock;
    }

    返回的对象是通道内部 注册 和修改 获取 boking模式的一把锁的对象
   
    只有获取了锁的线程才能对阻塞模式的更改


  
```


## ServerSocketChannel
```java
static ServerSocketChannel open() 创建 ServerSocketChannel 的对象
socket()  返回创建通道时绑定的ServerSocket 的对象


我们要使用bind()的方法只有先从
  chanel.socket()方法获取Serversocket 然后在进行绑定



accept()
    ServerSocketChannel
      accept()
      返货SocketChannel 能够在非阻塞模式下运行   

      no blocking model 下 call accept() method return null;
    ServerSocket
       accept()
       总是阻塞并返回一个Socket对象

   两种方法的调用都执行相同的的安全检查


```



## SocketChannel
```java
    Socket socket();
    其实返回是返回都是  
    this.socket = SocketAdaptor.create(this)


    new SocketAdaptor(var0);


    public class SocketAdaptor extends Socket {




    当我们调用  SocketChannel-->socket-->socky.getchannel    
   
    返回当channel 是  SocketChannel对象
    因为  当我们在创建Socket当时候
    this.socket = SocketAdaptor.create(this) 把 channle传入到里面去到

    //返回的就是 SocketAdaptor.create(this) 的this
    public SocketChannel getChannel() {
       return this.sc;
    }

注意:创建了channel但是我们是没有进行网络连接
当我们在没有超链接的channel进行IO操作会报错 java.nio.channels.NotYetConnectedException




boolean isConnected();
可以判断当前套接字是否是已经连接的s


connect()

1.传统的连接方式
socket.connect()  线程在连接建立好之前  or 超时过期之前 都是足赛的


2.channel.connet()   建立连接 默认(阻塞模式)  
通道上道connect()并没有设置超时的方法

boolean connect(SocketAddress var1)  ret true 建立连接  false没有建立连接

在非阻塞模式下  channel是提供并发连接的
     connect() true 可能是回环地址
     fasle 会继续去建立连接


boolean isConnectionPending();    true 当前正在进行连接，但是未连接成功




boolean finishConnect() //在任何时候都能进行安全的调用
在非阻塞情况下
    1.没有进行connect() or 没有任何连接操作  会跑出异常  NoConnectionPendingException
    2.进行了连接的操作 但是正在建立连接的过程调用 finishConnect 返回false;
    3.在非阻塞模式下调用connect 会切换变成阻塞模式，连接成功 finishConnect() 返回 true




read write  任何时候都只能保证只有一个执行

connection  和 isconnection 和 finishconnection  和 write read都是相互进行阻塞都 相互之间是同步当



``` 
## DatagramChannel
```
无连接协议 udp/ip


open()//常见channel当实例
socket()  获取关联当socket对象 DatagramSocket

DatagrameChannel 即能充当客户端也能充当服务端
     DatagramSocket  即有connect()也有 bind()

    udp 连接可以发送任意数据到任意到地址也能接收任意地址到数据  接收到的数据里面会带一个源地址(数据发送者的地址)
    我们虽然未bind()端口 但是channel在创建的时候会向os申请一个端口 发送端发送数据地址和端口都满足条件仍然能接收到消息


    int send(ByteBuffer src,SocketAddress target)//发送数据
       阻塞 可能回被加入到传输队列 
       非阻塞 返回值 要么 0 要么 要传输到字节数(all-or-nothing)
    SocketAddress receive(buffer)//接收数据   
       buffer 接收数据  注意  数据超过 buffer limit -postion 的大小回被丢弃
       SocketAddress  数据到来源  阻塞 会休眠到报包来到   非阻塞 返回null


安全管理器
   作用：每次send() 或receive()之前 执行 checkConnet()验证目的地址 除非是已经连接状态

   数据报传输(udp)是不安全到？？
       1.在网络中传输是有大小限制到超过回进行数据到拆分在进行传输(增大到丢数据到几率)
       2.接收数据网络层回进行数据到组合 组合完全(包未丢)交给上一层应用层  包不全时间已到数据丢弃




DatagramChannel connect(SocketAddress remote)

数据报的连接语意：
    除了对她连接对地址接收发送数据以外对任何地址都将会被忽略(在网络层就会被丢弃 这些数据根本就不会来到应用层)

    当我们在数据包进行了连接状态分设置，我们发送数据不是我们连接都地址会抛出 SecurityException

    
   检查是否连接 isConnect() 

   数据报连接不是tcp都连接 是对数据报对配置 ，可以任意次数连接和断开连接

   disconnet() 调用之后能再次进行通道对配置，能再次对安全管理器对对安装(若以前安装了安全管理器对发送接收有限制执行这个方法之后这个限制就关闭了 允许发送任意地址和接收任意地址对数据)。
   但是断开连接
   当我们read() 或这 write()之后会抛出  NotYetConnectedException
   read 和 write 和 send  recive 的功能是一样的的



数据报适合场景
1.允许数据一步分丢失
2.发送数据之后不关心数据是否接收
3.吞吐量比可靠性更加重要
4.多播广播的需求

```

## 管道
```java
Pipe 类
//创建管道类
Pipe open = Pipe.open(); //PipeImpl


SourceChannel //负责读的一端
SinkChannel //负责写的一端


PipeImpl.java

class PipeImpl extends Pipe {
    private final SourceChannel source;
    private final SinkChannel sink;

    PipeImpl(SelectorProvider var1) {
        long var2 = IOUtil.makePipe(true);
        int var4 = (int)(var2 >>> 32);
        int var5 = (int)var2;
        FileDescriptor var6 = new FileDescriptor();
        IOUtil.setfdVal(var6, var4);
        this.source = new SourceChannelImpl(var1, var6);
        FileDescriptor var7 = new FileDescriptor();
        IOUtil.setfdVal(var7, var5);
        this.sink = new SinkChannelImpl(var1, var7);
    }

    public SourceChannel source() {
        return this.source;
    }

    public SinkChannel sink() {
        return this.sink;
    }
}


根据上面的源码知道sink 和 source 是和Pip对象同时给创建出来的


```

