
```java
public final Buffer flip() {
    limit = position; //limit 限制设置成当前存储数据的位置
    position = 0;//位置设置开始位置
    mark = -1;
    return this;
}

作用 返回当前有效数据范围





public final boolean hasRemaining() {
    return position < limit;
}

是否有剩余
一般和 get() 方法结合起来进行使用



public final int remaining() {
    return limit - position;
}

还剩余元素的个数



   public ByteBuffer compact() {
    // 把么有使用的数据复制到 index为0开头的地方
        System.arraycopy(hb, ix(position()), hb, ix(0), remaining());
        position(remaining());//pos 为 复制的最后一个元素的下一个
        limit(capacity());//把limit 设置为数组len
        discardMark();
        return this;
    }

    作用:释放掉已经使用的数据







创建一个与原始缓冲区相似的缓冲区


    public ByteBuffer duplicate() {
        return new HeapByteBuffer(hb,
                                        this.markValue(),
                                        this.position(),
                                        this.limit(),
                                        this.capacity(),
                                        offset);
    }
注意：他们两个缓冲区共享里面的数据元素
  hb


对一个缓冲区里面的数据更新 添加 删除  会影响另一个   ByteBuffer对象



生成一个只读缓冲区 HeapByteBufferR
    public ByteBuffer asReadOnlyBuffer() {

        return new HeapByteBufferR(hb,
                                     this.markValue(),
                                     this.position(),
                                     this.limit(),
                                     this.capacity(),
                                     offset);



    }



分割缓冲区
    public ByteBuffer slice() {
        return new HeapByteBuffer(hb,
                                        -1,
                                        0,
                                        this.remaining(),
                                        this.remaining(),
                                        this.position() + offset);
    }


就是将剩余位置的数据单独把他分片


```


## java nio 字节排序问题
```java
big end : 0x1122

内存顺序  ...->11-> 22....



small end : 0x1122

内存顺序  ...->22-> 11....


小端
   Inter cpu 

 大端 
    PowerPC cpu....



** 网络使用的是大端的顺序


jvm 字节序
System.out.println(ByteOrder.nativeOrder());
打印:
LITTLE_ENDIAN

//设置ByteBuffer 缓冲区的排序问题

    public final ByteBuffer order(ByteOrder bo) {
        bigEndian = (bo == ByteOrder.BIG_ENDIAN);
        nativeByteOrder =
            (bigEndian == (Bits.byteOrder() == ByteOrder.BIG_ENDIAN));
        return this;
    }

   注意:buffer创建的时候就就设置
        在存入数据数据之后在进行设置=，不会影响原来存入缓冲区数据的顺序
 
```




### 直接缓冲区
```
直接缓冲区对象创建成本可能比非直接缓冲区成文要高。

不是JVM 堆栈创建 是调用本地操作系统创建的
所以 创建和销毁成本比较大

    public static ByteBuffer allocateDirect(int capacity) {
        return new DirectByteBuffer(capacity);
    }

    
释放os提供额内存

 public Cleaner cleaner() { return cleaner; }

 并且执行 remove()的方法进行 DirectByteBuffer对象的销毁

```


### 视图缓冲区
```java
    public LongBuffer asLongBuffer() {
        int size = this.remaining() >> 3;//Long= 8个 byte   个数/8==long的个数 
        int off = offset + position();
        return (bigEndian
                ? (LongBuffer)(new ByteBufferAsLongBufferB(this,
                                                               -1,
                                                               0,
                                                               size,
                                                               size,
                                                               off))
                : (LongBuffer)(new ByteBufferAsLongBufferL(this,
                                                               -1,
                                                               0,
                                                               size,
                                                               size,
                                                               off)));
    }


    //大端
    static long getLongB(ByteBuffer bb, int bi) {
        return makeLong(bb._get(bi    ),
                        bb._get(bi + 1),
                        bb._get(bi + 2),
                        bb._get(bi + 3),
                        bb._get(bi + 4),
                        bb._get(bi + 5),
                        bb._get(bi + 6),
                        bb._get(bi + 7));
    }  


    //小端

        static long getLongL(ByteBuffer bb, int bi) {
        return makeLong(bb._get(bi + 7),
                        bb._get(bi + 6),
                        bb._get(bi + 5),
                        bb._get(bi + 4),
                        bb._get(bi + 3),
                        bb._get(bi + 2),
                        bb._get(bi + 1),
                        bb._get(bi    ));
    }

```


## 数据元素视图
```

```