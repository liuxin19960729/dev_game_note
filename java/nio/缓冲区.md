
```java
public final Buffer flip() {
    limit = position; //limit 限制设置成当前存储数据的位置
    position = 0;//位置设置开始位置
    mark = -1;
    return this;
}

作用 返回当前有效数据范围





public final boolean hasRemaining() {
    return position < limit;
}

是否有剩余
一般和 get() 方法结合起来进行使用



public final int remaining() {
    return limit - position;
}

还剩余元素的个数



   public ByteBuffer compact() {
    // 把么有使用的数据复制到 index为0开头的地方
        System.arraycopy(hb, ix(position()), hb, ix(0), remaining());
        position(remaining());//pos 为 复制的最后一个元素的下一个
        limit(capacity());//把limit 设置为数组len
        discardMark();
        return this;
    }

    作用:释放掉已经使用的数据







创建一个与原始缓冲区相似的缓冲区


    public ByteBuffer duplicate() {
        return new HeapByteBuffer(hb,
                                        this.markValue(),
                                        this.position(),
                                        this.limit(),
                                        this.capacity(),
                                        offset);
    }
注意：他们两个缓冲区共享里面的数据元素
  hb


对一个缓冲区里面的数据更新 添加 删除  会影响另一个   ByteBuffer对象



生成一个只读缓冲区 HeapByteBufferR
    public ByteBuffer asReadOnlyBuffer() {

        return new HeapByteBufferR(hb,
                                     this.markValue(),
                                     this.position(),
                                     this.limit(),
                                     this.capacity(),
                                     offset);



    }



分割缓冲区
    public ByteBuffer slice() {
        return new HeapByteBuffer(hb,
                                        -1,
                                        0,
                                        this.remaining(),
                                        this.remaining(),
                                        this.position() + offset);
    }


就是将剩余位置的数据单独把他分片


```