```js
顶点着色器和片元着色器的图形到片元的转化又称为光栅化


1.将非坐标数据传入顶点着色器
    一：创建多个缓冲区的方式(适用于数据量不大的运用场景)
    如何在缓冲区数据传入顶点的多种数据并且使用
        1.在创建一个缓冲区
            let buffer=gl.createBuffer();
            let datas=new Float32Array([10.0,22.0,33.0]);
        2.在进行缓冲区数据的绑定

            gl.bindBuffer(gl.BUFFER_ARRAY,buffer);//BUFFER_ARRAY顶点缓冲区

            gl.bufferData(gl.ARRAY_BUFFER,datas,gl.STATIC_DRAW);

        3.获取程序里面的f_point_size 的attribute修饰的属性的地址
            //获取attribute属性的地址
            let pos_size=gl.getAttribLocation(gl.program,'f_point_size')
        4.将缓冲区分配给对应的attribute的属性
           gl.vertexAttribPointer(pos_size,1,gl.FLOAT,false,0,0)
        5.开启attribute的属性
           gl.enable.vertexAttribArray(pos_size)
      


      vertexAttribPointer()的步进和偏移参数

   二：将多种数据全部放在一个缓冲区
            运用 vertexAttribPointer() 里面的 stride (第5个参数) 和offset(第6个参数)进行设置
         
         stride：相邻两个顶点的默认字节数   (这里叫做步进参数) 单个顶点所有参数包含的大小



         offset: 缓冲区的偏移量(以字节为单位) 表示数据项距离首个元素的距离
  Float32Array.BYTES_PER_ELEMENT //每个元素的字节数





```
![图示一](./img/gl_vertexAttribPointer_stride_offset.png)



```js
varying变量 (只能是 float 以及相关 的vec[234] mat[234] )

顶点着色器和片元着色器之间的参数进行交流


uniform 可以使用但是不能够改变数值也就是有多个像素就需要多个变量而且两个着色器不能够进行数据的交流



```
### varying两个着色器传输数据图示
![varying数据传输](./img/varying_.png)






### 流程图
![流程图](./img/装配流程.png)

```js

rgba颜色分量值为0.0-1.0 之间



我们只传入三个颜色的参数为什么会造成三种颜色的平滑过渡？？？

几何形状的装配和光栅化
    我们绘制三角形-->创建了缓冲区-->并向缓冲区里面放了三个顶点的位置值(xy)



上图流程图顶点着色器--到片元着色器的流程

图元 基本图形  (点，线，面)
1.图形装配过程
    有gl.drawArrays() 的第一个参数 type决定 将孤立的的顶点装配成几何图形
2.光栅化过程 将装配好的图形转换成片元


gl.drawArray(type,count) count 设置为3

    1.将第一点进行赋值 gl_Position 
    把这个放在图形装配区域进行暂存

    2.第二个点也是

    3.第三个点存入装配区 已经执行了存入的count的次数

    4.拿着我们三个点然后获取type类型，根据类型进行装配

    4.我们的屏幕是像素组成，还需要将我们构成的图元进行光栅化构成片元(x像素)
```
### 流程图
![](./img/p-1.png)
![](./img/p2.png)

```js
图元光栅化后构成的片元的数目就是包含像素的数目
```

## 调用片元着色器
![调用片元着色器](./img/片元着色器的流程.png)
```
光栅化完成后-->逐个片元调用片元着色器

对于每个片元在计算出片元的颜色，并写入颜色缓冲区
当所有片元颜色存入缓冲区，在浏览器会显示最终的结果




片元着色器的内置属性
gl_FragCoord 类型 vec4
内置变量的分量  1 ,2 表示canvas 坐标系统的坐标值(gl.FragCoord.x,gl.FragCoord.y)


注意 canvas的坐标系是左上角为(0,0)

```
### Canvas坐标图示
![Canvas坐标图示](./img/canvas坐标.png)


```js
注意 canvas.y  越下越大



```


### varying 变量的作用和内插过程

```js
我们在顶点着色器进行赋值-->他会把值传给片元着色器厅类型同名的变量
注意  片元  着色器  varying 修的同类型和同名的属性



在赋值给片元着色器之前 做了差值的处理(内插过程)



```

### varying变量的内插过程

![varying变量的内插过程](./img/内插过程.png)


```js

也是说我们在varying 变量中实际值设置了三个点的颜色
而三角形其他的像素点的颜色都是内插出来的


例 我们要画同一条线段

a,b两个点 在图形装配成线段并且进行光栅化求出全部的像素

我们在顶点做色器 对 a ,b两个点 的varying变量进行赋值，但是

其他的像素的颜色值是内插出来的




颜色的内插






在矩形的表面贴上图片
    就是将 一张图像贴到一个由两个三角形组成的矩形上。
    这张图片就叫做纹理或叫做问题的图像
    
    纹理映射:根据纹理的图像，为之前光栅化的每个片元涂上合适的颜色，组成纹理图像的像素被称为纹素(rgb或rgba进行编码)


 
 在webgl中纹理映射遵循的步骤
        1.准备好纹理图像
        2.为几何图像配置纹理的映射方式
            片元 和 图素 怎样 进行 映射
        3.加载纹理的图像 并对其进行一些配置
        4.在片元着色器将纹素的颜色抽取出来，并且把它赋值给片元



纹理坐标 (一套新的坐标系统)
 通过纹理坐标可以获取纹素的颜色


```

### 纹理坐标

![纹理坐标](./img/纹理坐标.png)

```js
x 轴 和 y轴 的取值区域[0.0,1.0]

我们贴图的时候需要找到纹理图像的做标和webGL做标之间的映射关系




gl.createTexture() //创建一个纹理对象  返回 null 或 no-null






```

### 纹理单元图示
![纹理单元图示](./img/textTure.纹理单元.png)

```js
g.TEXTTURE0-gl.TEXTURE7 纹理单元



gl.deleteTexture(texture);  //删除一个纹理对象







gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL,1)
//对纹理进行y轴反转(是因为webgl的纹理坐标和图片的坐标y轴是相反的)




```

### webgl坐标系统和和图片的坐标系统相反
![](./img/webgl纹理坐标和图片坐标.png)


```js
gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL,1)
gl.pixelStorei(name,param)
name  
gl.UNPACK_FILP_Y_WEBGL 对图像进行y轴翻转  默认为false
gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL  对RGB的颜色每个分量乘a默认 false


param  0代表是false  非0 true




webgl通过纹理单元可以同时使用 多个纹理 
webgl总共有8个纹理单元
gl.activeTexture() //激活纹理单元

gl.TEXTURE0-gL.TEXTURE7 表示文件单元 


gl.activeTexture(gl.TEXTURE0)








绑定纹理的对象

gl.bindTexture(target,texture)

target :
gl.TEXTURE_2D: 二维纹理。
gl.TEXTURE_CUBE_MAP: 立方体映射纹理。
当使用 WebGL 2 context 时，可以使用以下值：
gl.TEXTURE_3D: 三维纹理.
gl.TEXTURE_2D_ARRAY: 二维数组纹理.


texture 绑定的纹理单元

```

### 图示使用的纹理单元和绑定纹理的图示

![图示使用的纹理单元和绑定纹理的图示](./img/绑定纹理对象和使用的纹理单元.png)







```js
配置纹理对象的参数
设置纹理图像映射到图形的具体方式：如何根据纹理坐标获取纹素颜色，按那种方式填充纹理

gl.getTexParamete(target,pname,param)

target:gl.TEXTURE_2D: 一个二维纹理.
gl.TEXTURE_CUBE_MAP: 一个立方体纹理.
当使用 WebGL 2 context接口, 可能会出现以下值:
gl.TEXTURE_3D: 一个三维纹理.
gl.TEXTURE_2D_ARRAY: 一个二维纹理数组.



pname  https://developer.mozilla.org/zh-CN/docs/Web/API/WebGLRenderingContext/getTexParameter






将纹理图像分配给纹理对象(将纹理图像存储在WebGl的纹理对象中)


gl.texImage2D(target,level,internalformat,format,type,image)

target:
    gl.TEXTURE_2D: 二维纹理贴图.
    gl.TEXTURE_CUBE_MAP_POSITIVE_X:立方体映射纹理的正X面。
    gl.TEXTURE_CUBE_MAP_NEGATIVE_X: 立方体映射纹理的负X面。
    gl.TEXTURE_CUBE_MAP_POSITIVE_Y: 立方体映射纹理的正Y面。
    gl.TEXTURE_CUBE_MAP_NEGATIVE_Y: 立方体映射纹理的负Y面。
    gl.TEXTURE_CUBE_MAP_POSITIVE_Z: 立方体映射纹理的正Z面。
    gl.TEXTURE_CUBE_MAP_NEGATIVE_Z: 立方体映射纹理的负Z面。

level:
   0级是基本图像等级，n级是第n个金字塔简化级.  
   
   

internalformat：
    指定纹理中的颜色组件.


format: 纹理数据的格式
    jpg RGB 分量表示
    png gl.RGBA表示
    bmp  RGB表示

    //下面表示的灰度图像
    gl.LUMINANCE
    gl.LUMINANCE_ALPHA  

    https://developer.mozilla.org/zh-CN/docs/Web/API/WebGLRenderingContext/texImage2D
 image:包含纹理图像的 Image对象  





 .....



将纹理单元传给片元着色器
   uniform sampler2D u_Sampler



用于纹理的数据类型
    sampler2D 绑定到gl.TEXTURE_2D 上的数据类型

    samplerCube 绑定到gl.TEXTURE_CUBE_MAP 上的纹理数据类型


gl.uniformli(u_Sampler,0) //将0号纹理单元 传给 u_Sampler对象



```

![](./img/着色器u_Sampler对象.png)


```js
texture2D() GLSL 的内置函数

抽取纹素的颜色

vec4 texture2D(samoler2D,coord)

coord vec2  纹理的坐标
sampler 纹理单元编号






使用多副纹理



```