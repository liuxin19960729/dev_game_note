# Zero Copy技术
```
现带网络应用的性能瓶颈:I/0

传统的Linux io 接口 数据拷贝操作
    什么是数据拷贝操作？
        1.os kernel 缓冲区------>application 缓冲区  之间进行传输
        
        设置缓冲好处：减少disk io  
            当数据未放在缓冲区-->访问数据就要进行 磁盘 io-->会依赖(深度)cpu去操作 -->拷贝数据的时候会极大依赖cpu-->导致极大的系统的开销-->这样会导致传输效率非常慢

    io效率低下，这样有会影响网路服务器性能地下-->根据木桶规则，io是他的短板(瓶颈)-->解决了这个问题-->网络服务器性能也会提高

```



## 计算机存储器
![存储器分类](./imgs/z_cp_1.jpg)
```
存储器理想状态具备的特征
    1.速度快
    2.容量大
    3.价格便宜

很显然我们的计算机无法满足条件

由上图可知
    寄存器、高速缓存、主存和磁盘 这些存储器的速度递减的容量是递增的


    寄存器：
        32位cpu r32bits
        64位cpu r64 bits

        容量小价格非常昂贵

    高速缓存   
              

    主存(RAM)
        作用:与cpu直接交换数据的内部存储
        速度快

    磁盘
        便宜，效率低

```


## 物理内存

```
加载各式各样的程序与数据以供 CPU 直接运行和使用。

```


## 虚拟内存

```
虚拟内存的出现解决了程序日益增加的内存需求。


mov cx, 2
mov bx, 1000H
mov ds, bx
mov [0], cx

...

mov ax, [0]
add ax, ax




1.绝对地址访问内存
当使用绝对地址作为访问物理内存,并发执行程序可能会对进程间产生互相干扰。(修改到到同一绝对地址上)
因此上面的绝对地址访问内存的方案是不可行的方案

2.相对地址 (每个进程有一个自己的地址) index=0 开始进行访问
   物理地址=进程地址+index

    若个16kb的程序AB
    A：0-16384
    B: 16384-32768


    A的 第一条指令 jmp 1024   1024处是一条 mov next一条 add 

    B的第一条指令 jmp 1028  1028处 mov  next一条 add 指令 


    这两个程序共享的是寄存器-虽然使用的是各自的相对地址但是本质上操作的是绝对的内存地址--有可能会非法进行操作其他程序内存的内容  cs 是共享的 所以他们是cs+index 




3.静态重定位
    工作原理：当B程序加载到内存16384后，当执行jmp 1028 的时候-就会把jmp 1028+16384 去执行对应的指令，但是这个技术并不通用，而且对程序装载金内存有性能上的影响


4.存储器抽象:地址空间(就好像进程是CPU的抽象，地址是存储器的抽象,每个进程分配独享的地址空间)

    会出现新的问题:
        如何实现不同进程，相同的相对的地址实现不同的物理地址？？？

        答：
            1 最开始使用的是【动态重定位技术】  简单的地址空间到物理内存的映射方法
            cpu 配备了两个寄存器 基地址存储器+界线存储器(动态保存程序的起始地址 base address 和 程序的长度 length )

            A  0 -16384
            B 16384 - 32768

            当我们每次访问内存地址的时候 cpu 会自动把基地址寄存器 加到内存地址上 得到一个正确的内存地址 同时还会根据界线寄存器的值检查得到的内存地址是否溢出，若溢出产生错误终止程序

            问题 每次访问内存都会进行加法和比较运算，加法运算由于进位传递时间的问题，除非使用特殊的电路，否则会比较慢。





```
5,交换 swapping 技术

![交换 swapping 技术](./imgs/swap_1.jpg)

```

什么是交换技术？？？
    简单来说就是动态的把程序在内存和磁盘之间进行交换保存，要运行一个程序的时候吧程序的代码段和数据段调入内存，然后在把程序封存封存，存入磁盘，如此反复？？？

    为什么要这样呢？(swapping)
        前面的重定实现起来有一个前提空间足够的大，能够把他们全部加载到进程，才能并发运行这些进程，但是内存是有限的，所以就需要一种方法来处理内存【超载的情况】，【交换技术就是处理内存超载的问题】




   上图
    进程A换入内存 --启动进程BC--A从内存交换到磁盘--D进程加载到内存用了A进程退出之后的内存空间--A又被重新加载到内存，这时候内存布局又发生了变化所以A在换入内存时会通过软件和（基地址寄存器+界线寄存器）对A进程进行重定位




```


6 虚拟内存技术
![页一](./imgs/page_1.jpg)
```
这个技术也是和swapping技术一样处理内存超载的技术



虚拟内存核心原理？？
    为每个程序设置一段"连续"的虚拟地址空间(把这个地址空间分割多个具有连续地址范围的页--并把这些页和物理内存做映射)。在程序运行期间，动态映射到物理内存。

    当程序引用到一段物理内存地址空间时,硬件立即执行必要的映射；而当程序引用到一段不在物理内存的地址空间时，由操作系统将缺失的部分装入物理内存并重新执行失败的指令




    上图 虚拟内存的图


    内存分割-- page(固定大小)若干--物理内存对应的是page frame (页框) 图中是4k 在实际os中一般是512 byte到1GB 其实这种技术就是虚拟内存中的分页技术


    在32位架构中 
        虚拟内存空间分配的大小是4GB，在实际上当然不可能将所有运行中的进行分配4GB的物理内存，所以虚拟内存还需要利用到前面的交换(swapping)技术,在进程运行期间只分配映射当前的使用的内存，动态的在磁盘和内存之间进行交换





```

### MMU (Memory Management unit)

![mmu_1](./imgs/mmu_1.jpg)

```

```