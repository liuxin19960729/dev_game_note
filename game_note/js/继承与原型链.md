
## 介绍
```
JavaScript 只有一种结构：对象
__proto__  属性私有属性 指向构造函数的原型对象属性(这个原型对象也有自己的原型对象)

几乎所有的对象的原型对象的最顶端都是Object的实例


```



## 基于原型链的继承

```js
当我们使用一个对象的属性时,他不仅在改对象的属性上面进行搜寻，还会搜寻该对象的原型，依次层层向上搜索，知道找到一个名字匹配的属性，或者达到原型链的末端(当前对象-->原型->原型的原型依次向下知道找到活到末尾)



ECMAScript标准 
   obj[[prototype]]  可以访问obj原型的属性 是这个函数的property 





   
function Tclass(a,b,c){
    console.log(arguments);
    this.a=a;//把Tclass的原型的a属性覆盖了
    this.b=b;
    this.c=c;
   
}

window.onload=function(){
    console.log("加载完整");

    let t1=new Tclass(1,2,4);

    Tclass.prototype.a=100;

    t1[[ ]]//相当于 o.__proto__ 或者 o.constructor.prototype





    Tclass.prototype.d=100

    console.log(t1.d);//给原型添加一个 d属性  t1对象也就继承下来了

}


```


## 继承的方法

```js
var o = {
  a: 2,
  m: function(){
    return this.a + 1;//this 指向了 o对象
  }
};

console.log(o.m()); // 3
// 当调用 o.m 时，'this' 指向了 o.


//创建一个继承的对象
var p = Object.create(o);
// p是一个继承自 o 的对象



p.a = 4; // 创建 p 的自身属性 'a'
console.log(p.m()); // 5


//就相当于其他面向对象语言的函数 extends

Object.create(obj) 创建一个继承obj对象的对象


```



## 在 JavaScript 中使用原型

```
javascript 函数允许拥有私有属性

Fun.prototype.xxx=fun|param (函数私有属性)




```


## 使用不同的方法来创建对象和生成原型链

```
Object对象的继承
var o = {a: 1};

因为 o __proto__  Object

所以 o继承了 Object的所有属性




Array()对象的继承 (所有数组都对Array的属性进行继承)


Aarray对象继承-->Array  Array继承-->Object



fun方法 继承--> Function 继承 ->Object

```


## ECMAScript6 引入了新的创建方法的方式

```js
class Polygon {
  constructor(height, width) {
    this.height = height;
    this.width = width;
  }
}

class Square extends Polygon {
  constructor(sideLength) {
    super(sideLength, sideLength);
  }
  get area() {
    return this.height * this.width;
  }
  set sideLength(newLength) {
    this.height = newLength;
    this.width = newLength;
  }
}

var square = new Square(2);





```
