# 命令模式
```ts
命令是具现化的方法调用
    具现化:实例化，具象化
命令模式是一种回调的面向对象的实现



例子: 游戏的读取键盘的输出事件
void handleInput()
{
  if (isPressed(BUTTON_X)) jump();
  else if (isPressed(BUTTON_Y)) fireGun();
  else if (isPressed(BUTTON_A)) swapWeapon();
  else if (isPressed(BUTTON_B)) lurchIneffectively();
}


改进:将游戏允许玩家配置按键的功能


定义一个基类触发游戏的行为
class Command
{
    execute():void{
       
    }
}



定义游戏不同的子类

class JumpCommand extends Command
{
   void execute(){ jump(); }
   
}

class FireCommand extends Command
{
   execute(){ fireGun(); }
}



代码输入处理部分


class InputHandler
{

  public  void handleInput();

  // 绑定命令的方法……
  private Command  buttonX_;
  private  Command buttonY_;
  private  Command buttonA_;
  private Command  buttonB_;
    //出入处理这部分
    void  handleInput()
    {
    if (isPressed(BUTTON_X)) buttonX_.execute();
    else if (isPressed(BUTTON_Y)) buttonY_.execute();
    else if (isPressed(BUTTON_A)) buttonA_.execute();
    else if (isPressed(BUTTON_B)) buttonB_.execute();
    }
}






角色说明
    把角色传进去不让函数去找他们的角色-->我们主动将角色对象传进去

    class Command
    {
        execute(actor:GameActor):void{
        
        }
    }


class JumpCommand extends Command
{
   void execute(actor:GameActor){ actor.jump(); }
   
}

class FireCommand extends Command
{
   execute(actor:GameActor){ actor.fireGun(); }
}

//修改刚才的代码让他输出命令找到对应的对象
Command  handleInput()
{
  if (isPressed(BUTTON_X)) return buttonX_;
  if (isPressed(BUTTON_Y)) return buttonY_;
  if (isPressed(BUTTON_A)) return buttonA_;
  if (isPressed(BUTTON_B)) return buttonB_;

  // 没有按下任何按键，就什么也不做
  return NULL;
}


Command command = inputHandler.handleInput();
if (command)
{
  command->execute(actor);
}


优点  我们可以让玩家控制游戏中的任何角色，只需向命令传入不同的角色。 也就是说角色和输入命令的逻辑分开了可以控制每个角色，秩序要在excete 传入对应的角色



```
