###  1.为什么需要纹理压缩格式
```
1.内存方面
    手机,等一些其他低端设备本来内存大小就有限，所以需要内存资源方面限制

2.网络传输
    由于纹理资源非常大，宽带会比较长的时间进行大规模的数据的传输，
    会造成手机发烫

3.在3d场景渲染时，大量的纹理资源会被传输的GPU进行渲染，这样一来宽带的传输可资源到GPU的渲染 ,宽带的输出效率就是瓶颈




综合上面的问题我们需要选用的压缩格式需要是一个 【内存占用既小又能被GPU读取的格式】



纹理压缩对应的算法:以某种形式的 【固定速率】 【有损】【向量量化】固定大小的像素块编码进固定大小的字节块中

有损:有损压缩是可以接受的，一般选择压缩格式时需要在纹理质量和文件大小上寻求一个平衡。(在文件大小和纹理质量之间寻求一个平衡)



固定速率压缩：
    GPU 需要能够高效的访问随机的一个像素

    所有 我们使用的压缩算法 对任意的一个像素解码速度有要求(要求:所有像素解码速度平衡和高效)




向量量化:


    
   
编码和解码速度 :
    编码：没关系打包是才用
    编码：解码速度必须足够快，而且基本上不能影响到渲染性能



压缩比:    
    例：
        rgb 原生纹理像素
        3*8=24 bits

        4bpp 表示每个像素4位

        所以压缩比位 24：4  =6：1





```



cocos 压缩执行流程

```
在进行构件时

cocos-->对应的平台
    若没有设置 cocos-->default

    若没有设置则 cocos 使用原图




运行时
    生成的图片不会全部加载(engine 会选择合适格式的图片进行加载)

例：
    Web 平台配置了 pvr、png 格式的压缩纹理
    当我们进行Web构件的时候会生成两种格式图片文件
    ios 会加载 pvr
    其他平台 png
```

压缩类型
```
ETC1：
只能压缩RGB 3通道值  6：1的压缩率(3byte:0.5byte)
只支持安卓和安卓的web浏览器


ETC1_Separate Alpha 支持4通道



PVR:
    支持 iOS 设备  ios的web浏览器

    rgb 4bp 6:1
    rgb 2bp 12:1

    rgba 4bp 8:1 (4:0.5)

    rgba 2bp 16:1 (4:0.25)


压缩 体积降小--网络传输变快 内存变小  
响应的图片质量也差会降低

```