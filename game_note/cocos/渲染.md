## cc.Node
```js
constrcuct:
    this._renderFlag
         RenderFlow.FLAG_TRANSFORM| RenderFlow.FLAG_OPACITY_COLOR

color:
     this._renderFlag |= RenderFlow.FLAG_COLOR;

......


this._renderFlag:




markForRender (enable) {
    let flag = RenderFlow.FLAG_RENDER | RenderFlow.FLAG_UPDATE_RENDER_DATA;
    if (enable) {//允许渲染更新
        this.node._renderFlag |= flag;
        this.markForValidate();//做验证
    }
    else {//标记清空
            this.node._renderFlag &= ~flag;
    }
},



markForValidate () {
    cc.RenderFlow.registerValidate(this);
},

RenderFlow.registerValidate = function (renderComp) {
    if (renderComp._inValidateList) return;//已经进行了验证
    _validateList.push(renderComp);//加入验证的队列
    renderComp._inValidateList =  true;//更新验证状态
};




//进行验证
RenderFlow.validateRenderers = function () {
    for (let i = 0, l = _validateList.length; i < l; i++) {
        let renderComp = _validateList[i];
        if (!renderComp.isValid) continue;//判断当前对象是否可用
        if (!renderComp.enabledInHierarchy) {//该组件是否处于激活状态
            renderComp.disableRender();//标记不能渲染
        }
        else {
            renderComp._validateRender();//标记前的准备工作
        }
        renderComp._inValidateList = false;
    }
    _validateList.length = 0;
};


/*
   标记不能渲染 
   设置不能够渲染 不能够更新渲染数据
*/
disableRender () {
    this.node._renderFlag &= ~(RenderFlow.FLAG_RENDER | RenderFlow.FLAG_UPDATE_RENDER_DATA);
},



cc.Sprite为例

_validateRender () {
    let spriteFrame = this._spriteFrame;
    if (this._materials[0] &&spriteFrame && 
        spriteFrame.textureLoaded()) {
        return;
    }

    this.disableRender();
    },
```

## 渲染
```js


mainLoop(){
    .....
    renderer.render(this._scene, deltaTime);
    .....
}


//初始化
RenderFlow.init = function (batcher, forwardRenderer) {
    _batcher = batcher;
    _forward = forwardRenderer;

    flows[0] = EMPTY_FLOW;
    for (let i = 1; i < FINAL; i++) {//FINAL 总共的渲染处理器个数
        flows[i] = new RenderFlow();
    }
};


render (ecScene, dt) {
    this.device.resetDrawCalls();
    if (ecScene) {
        // walk entity component scene to generate models
        this._flow.render(ecScene, dt);
        this.drawCalls = this.device.getDrawCalls();
    }
},

//普通
RenderFlow.render = function (rootNode, dt) {
    _batcher.reset();
    _batcher.walking = true;

    RenderFlow.visitRootNode(rootNode);

    _batcher.terminate();
    _batcher.walking = false;

    _forward.render(_batcher._renderScene, dt);
};


//渲染相机
RenderFlow.renderCamera = function (camera, rootNode) {
    _batcher.reset();
    _batcher.walking = true;

    RenderFlow.visitRootNode(rootNode);

    _batcher.terminate();
    _batcher.walking = false;

    _forward.renderCamera(camera, _batcher._renderScene);
};

//场景节点
RenderFlow.visitRootNode = function (rootNode) {
    RenderFlow.validateRenderers();    

    let preCullingMask = _cullingMask;
    _cullingMask = rootNode._cullingMask;

    if (rootNode._renderFlag & WORLD_TRANSFORM) {
        _batcher.worldMatDirty ++;
        rootNode._calculWorldMatrix();
        rootNode._renderFlag &= ~WORLD_TRANSFORM;

        flows[rootNode._renderFlag]._func(rootNode);

        _batcher.worldMatDirty --;
    }
    else {
        flows[rootNode._renderFlag]._func(rootNode);
    }

    _cullingMask = preCullingMask;
};

RenderFlow.visitRootNode = function (rootNode) {
    RenderFlow.validateRenderers();    

    let preCullingMask = _cullingMask;
    _cullingMask = rootNode._cullingMask;

    if (rootNode._renderFlag & WORLD_TRANSFORM) {
        _batcher.worldMatDirty ++;
        rootNode._calculWorldMatrix();
        rootNode._renderFlag &= ~WORLD_TRANSFORM;

        flows[rootNode._renderFlag]._func(rootNode);

        _batcher.worldMatDirty --;
    }
    else {
        flows[rootNode._renderFlag]._func(rootNode);
    }

    _cullingMask = preCullingMask;
};

```


## RenderFlow

```js
//单链表
function RenderFlow () {
    this._func = init;
    this._next = null;
}

/*
  初始化方法
  flows[0] 是一个默认的空 RenderFlow的对象
*/
RenderFlow.init = function (batcher, forwardRenderer) {
    _batcher = batcher;
    _forward = forwardRenderer;

    flows[0] = EMPTY_FLOW;
    for (let i = 1; i < FINAL; i++) {
        flows[i] = new RenderFlow();//先给 flows[i] 初始化为 RenderFlow对象
    }
};





//开始使用

flows[rootNode._renderFlag]._func(rootNode);



flows[rootNode._renderFlag]

执行的时候一定是一个单链表初始化的时候的没有其他节点的对象
function RenderFlow () {
    this._func = init;
    this._next = null;
} 

invoke   --> _func(rootNode)

一定是执行的init()方法

function init (node) {
    let flag = node._renderFlag;
    let r = flows[flag] = getFlow(flag);
    r._func(node);
}


getFlow(flag); 是根据当前的falg 把从前到后的渲染方法按顺序全部放入到链表上返回


r._func(node); 执行当前节点和字节点的渲染数据计算


```

## 相机渲染 相机数据渲染管线数据的计算
```

```

## 渲染任务的执行 跟新矩阵数据  用于渲染管线使用
```

```



## ForwardRenderer 渲染 
```js

 _forward.render(_batcher._renderScene, dt); 






  _render (view, scene) {
    const device = this._device;

    // setup framebuffer
    device.setFrameBuffer(view._framebuffer);

    // setup viewport
    device.setViewport(
      view._rect.x,
      view._rect.y,
      view._rect.w,
      view._rect.h
    );

    // setup clear
    let clearOpts = {};
    if (view._clearFlags & enums.CLEAR_COLOR) {
      clearOpts.color = Vec4.toArray([], view._color);
    }
    if (view._clearFlags & enums.CLEAR_DEPTH) {
      clearOpts.depth = view._depth;
    }
    if (view._clearFlags & enums.CLEAR_STENCIL) {
      clearOpts.stencil = view._stencil;
    }
    device.clear(clearOpts);

    // get all draw items
    this._drawItemsPools.reset();

    for (let i = 0; i < scene._models.length; ++i) {
      let model = scene._models.data[i];

      // filter model by view
      if ((model._cullingMask & view._cullingMask) === 0) {
        continue;
      }

      let drawItem = this._drawItemsPools.add();
      model.extractDrawItem(drawItem);
    }

    // dispatch draw items to different stage
    _stageInfos.reset();

    for (let i = 0; i < view._stages.length; ++i) {
      let stage = view._stages[i];
      let stageItems = this._stageItemsPools.add();
      stageItems.reset();

      for (let j = 0; j < this._drawItemsPools.length; ++j) {
        let drawItem = this._drawItemsPools.data[j];
        let passes = drawItem.effect.stagePasses[stage];
        if (!passes || passes.length === 0) continue;

        let stageItem = stageItems.add();
        stageItem.passes = passes;
        stageItem.model = drawItem.model;
        stageItem.node = drawItem.node;
        stageItem.ia = drawItem.ia;
        stageItem.effect = drawItem.effect;
        stageItem.defines = drawItem.defines;
        stageItem.sortKey = -1;
        stageItem.uniforms = drawItem.uniforms;
      }

      let stageInfo = _stageInfos.add();
      stageInfo.stage = stage;
      stageInfo.items = stageItems;
    }

    // render stages
    for (let i = 0; i < _stageInfos.length; ++i) {
      let info = _stageInfos.data[i];
      let fn = this._stage2fn[info.stage];
      fn(view, info.items);
    }
  }
```