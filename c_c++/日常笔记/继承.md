## 继承
```cpp
格式
class Derived : [virtual] [access-specifier] Base
{
   // member list
};

上面这种方式的声明基类必须提前声明

[access-specifier]  public protected private 访问符
   对基类成员使用派生类的权限(默认访问 private)
   

virtual 存在表明是虚拟继承 派生类 表示虚拟类
基类可以是多个 用 ,分隔

```

### 派生类中的成员访问控制
```cpp

class BaseClass
{
public:
    int PublicFunc(); // Declare a public member.
protected:
    int ProtectedFunc(); // Declare a protected member.
private:
    int PrivateFunc(); // Declare a private member.
};
1. 基类中 private  派生类都是无法访问的

2.class DerivedClass1 : public BaseClass 
    public BaseClass   公共基类
    当我们在派生类中访问
       private不能访问
       其他的基类是什么访问权限那么继承过来就是什么权限

class DerivedClass2 : private BaseClass
    基类的所有都不能访问

规律 基类的访问修饰符 代表的是 最高访问权限
   基类里面成员 >=基类访问修饰符  访问就是符就是基类访问修饰符
   剩下的就是他本来的修饰符    
```

## 单个继承
```

当在派生类中重新定义了直接或间接基类的成员时，范围解析运算符 (::) 可用于引用这些成员(对成员和实现)
#include <iostream>
using namespace std;
class Document {
public:
   char *Name;   // Document name.
   void PrintNameOf();   // Print name.
};

// Implementation of PrintNameOf function from class Document.
void Document::PrintNameOf() {
   cout << Name << endl;
}

class Book : public Document {
public:
   Book( char *name, long pagecount );
private:
   long  PageCount;
};

// Constructor from class Book.
Book::Book( char *name, long pagecount ) {
   Name = new char[ strlen( name ) + 1 ];//public 对基类的成员属性有访问权限 所有对基类的成员变量进行赋值
   strcpy_s( Name, strlen(Name), name );
   PageCount = pagecount;
};




#include <iostream>
using namespace std;

class Document {
public:
   char *Name;          // Document name.
   void  PrintNameOf() {}  // Print name.
};

class Book : public Document {
   Book( char *name, long pagecount );
   void PrintNameOf();
   long  PageCount;
};

void Book::PrintNameOf() {//当 PrintNameOf在Book中进行了重新的实现
   cout << "Name of book: ";
   Document::PrintNameOf(); //那么如果要调用基类的用一名字的方法 只能  xx::methodname();
} 



```