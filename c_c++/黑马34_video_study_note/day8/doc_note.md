## 多级指针

```
一级指针 变量的地址
二级指针 一级指针的地址

三级指针 二级指针的地址

........



强调：多级指针不能跳跃定义
        定义二级指针必须要有一级指针
        定义三级指针必须要有二级指针
        ......

总结
    解引用
       int *** ppp=;是一个三级指针

       *ppp 二级指针  (3-1)
       **ppp 一级指针 (3-2)
       ***ppp 变量的数据 (3-3)

```



栈帧概念
```c
void swap(int a, int b);

int main() {
	int m = 100;
	int n = 10;
	printf("swap before  m: %d   n:%d  \n", m, n);
	swap(m, n);
	printf("swap after  m: %d   n:%d  \n", m, n);
	system("pause");
	return 0;
}

void swap(int a, int b) {
	int temp = a;
	a = b;
	b = temp;
}



打印结果发现上面代码的值 m ,n的值根本就没有进行交换




栈帧
        当函数调用时，系统会在stack申请一块内存区域，用来提供函数调用
        存放形参和局部变量(方法里面声明的变量)。
        当函数调用结束，这块内存区域自动被释放


其实上面代码没有按照我们想的执行最主要原因是
他传入形参的值是把值压栈 在方法里面执行时弹栈的数据，更笨就没有修改到真正m，n内存上的值



解决方法 传地址(指针)
        在放发里面使用指针反引用找到地址的位置进行修改值


code
void swap(int *a, int *b) {
	int temp = *a;
	*a = *b;
	*b = temp;
}



```

数组做函数的参数

```
  形参数组
        在方法里面这个形参的数组其实是指针

        例 int a(int arr[])====int a(int* arr);

        数组是函数形参的话其实传入的不是数组而是数组的首地址
        也就是形参的的变量就是指针类型




为了让我们知道传入数组的大小解决方法可以在外面传入数组大小
方法(通常的解决方法)

函数形参数组 传递的是数组的首地址



```

指针做函数的返回值

```
  int * a();


注意：
        不能返回函数内部声明的指针
        因为局部变量随着方法执行完而销毁
        
        返回的地址也就没有意义了



```


数组做函数的返回值

```
 在c语言中不允许返回数组

```





指针和字符串

```
字符串
  char str[]={....'\0'};//数组定义

    char str[]="hi";//数组定义



 char *str="hi" ;//指针定义

   


   注意：
        char * str = "123";

	str[0] = 'D';//常量不允许
        
        char * str = "123";

	*str = 'D';//常量不允许

        //指针定义 这总方式定义出来的是字符串的常量,不允许修改





数组
  char str[]={....'\0'};//数组定义

    char str[]="hi";//数组定义

    不是常量是允许修改的





常量字符串
        char * str = "123";

当我们使用字符指针声明字符串的时候他们的声明的字符串声明的是常量

声明多个 统一常量的字符串 他们指的地址是同一块区域






当字符数组做函数参数时，不需要提供两个参数，因为每个字符串都有 \0 的结束标记


```






