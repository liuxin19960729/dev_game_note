指针
```
指针 地址

内存单元：计算机中最小的内存单位(byte)

地址：内存单元的编号

	int a = 10;
	printf("a 的地址 %p \n",&a);

a 的地址 00BFFD80

 a的内存图 
 
 00BFFD83   0000 0000
 00BFFD82   0000 0000
 00BFFD81   0000 0000
 00BFFD80   0000 1010





指针变量:存储地址的变量




*p (解引用)  将p变量的内容取出，当成地址看待，找到p地址的内存空间。

做左值  存数据到空间中

右值  取出空间中的内容




指针类型的大小
    所有指针类型的大小为 4byte
    与数据类型无关
    只和操作系统的架构有关  32 位(4个byte) 64位(8个byte)





野指针
    int *p ;p 是操作系统的给的随机数作为地址 这样不行的
    int *p=1000 1000就是一个不能够访问的地址(经过测试报错的是没有写入读取的权限)
 
    定义：没有一个有效的地址空间叫做是野指针


    结论：指针的赋值一定要先申请空间，在进行拿空间的地址值对执行进行赋值


空指针
    NULL //0

    int * i_p=NULL

    if(i_int!=NULL){
        使用该指针
    }

    作用 ：是指针 不用出现投机的操作
    0-255 的地址不管是那个系统都是属于系统用的空间，其他的程序访问这个地址的空间都没有访问的权限



万能指针
    int a=15;
    void * p;

    p=&a;

  	int a;
	void *v_p;
	v_p = &a;

	printf("a value :%d\n", a);
    printf("*v_p vale: %d\n", *((int *)v_p));

    (int *)强转 高速程序我们他当成怎么类型看待 意思说高速程序我们那到地址-找到空间--取多少大小范围的数据






```





指针和数组
```c
数组名是地址常量
        常量：不允许修改

    int a[10] = { 0 };
	int b[10] = { 0 };
	a = b;//错误 常量不允许修饰

    
注意:两个数组名之间是不允许进行赋值操作的(数组名是地址常量)
    可有把数据名赋值个同类型的指针



	int a[10] = { 100 };

	int *p = a;

	for (size_t i = 0; i < sizeof(a)/sizeof(a[10]); i++)
	{
		int data = *(p+i);//p[i]  这个操作也是可以的

		printf("i:%d  v:%d \n", i, data);
	}



arr[0] 代表的含义
  arr[0]== *(arr+0)
  
  &(arr[0])==arr  地址形同

指针加减和地址的关秀 :所用对象到地址是加 index*(存储数据类型占空间的大小)






```

指针和变量的区别

```
    1.指针是变量  数组名是地址常量
    2.sizeof(指针)  4 /8  os相关
        sizeof(数组名) 数组所有元素的字节数的总和



```


指针++操作

```
取数组每个元素
	int a[10] = { 100,200 };
	
	int *p_a = a;

	for (size_t i = 0; i < sizeof(a)/sizeof(a[0]); i++)
	{
		printf("%p -- v: %d \n", p_a, *p_a);
		p_a++;
	}
	system("pause");

p_a++ 地址加的就是 int 占的内存大小



int *p *指针描述符

*p *解引用描述符





指针

数据类型对指针的作用
    1.间接引用 (从地址对应内存空间开始位置，向后读取的字节数)

    2.加减运算
        决定指针决定 — +1 地址的加的字节数

        
```





