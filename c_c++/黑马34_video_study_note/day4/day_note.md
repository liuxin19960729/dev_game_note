### 数组
```c
定义：相同数据类型的有序集合
    相同数据类型
    有序的


int array[10]={.....}

10个元素是连续的存储(每个元素占4个字节)

数组名和数组首元素的地址相同(arra=&array[0])




数组的大小
注意sizeof 返回的是 unsigned int

    sizeof(array)  算出这个数组在内存中占用的字节数

    sizeof(array[0])  计算出数组一个元素占用的字节数

    sizeof(array)/sizeof(array[0]) 计算出这个数组的元素的个数



数组的初始化
    int arr[10]={......(10个)}    
    int arr[10]={......少于10个}
        后面(剩余位)的初始化(编译器会把他设置为默认值)默认设置为0   


    int arr[10] ;不初始化操作系统会给他里面的元素指定随机数(不推荐使用)




   int arr[]={1,2,3} 这样也是可以的编译器根据后面的{1,2,3}求取元素个数


    int arr[]={0} //只有一个元素的数组 和上面 int arr[10]={0}不同

  
    



```


二维数组
```c

int arr [行] [列]={
    {},0行
    {},1行
}


	int arr[3][4] = { {1,2,3,4},{22,33,55,22},{2,4,1,2}};
	for (size_t h = 0; h < sizeof(arr)/sizeof(arr[0]); h++)//行
	{
		for (size_t l = 0; l < sizeof(arr[0])/sizeof(arr[0][0]); l++)
		{
			printf("%u ", arr[h][l]);
		}
		printf("\n");
	}

 sizeof(arr)/sizeof(arr[0]) 行数=总字节数/每行的字节数


sizeof(arr[0])/sizeof(arr[0][0]) 列数(每行有多少个元素)=每行的字节数/每个元素的字节数




地址
  二维数组的地址和一位数组的地址定义一样

  printf("%p",arr)==printf("%p",&arr[0][0])==printf("%p",&arr[0]);
   总结
   数组名==等于数组的首元素的地址 ==首行的地址

    arr==&arr[0][0]
    arr[0]//行也是一个一位数组 arr[0]相当于这个一位数组的名
    arr[0]==&arr[0][0];//一维数组的名等于一位数组的第一个元素的取地址

    arr=arr[0]=&arr[0][0]



二维数组的不完全初始化
    int array[3][4]={0}

    和一位数组的规则一样，初始化二维数组，有些元素未初始化，编译器会帮助我们把它进行初始化为0


    int array[3][4]={1,2,3,4};

    上面的这总初始化的方式编译器进行编译的时候会自动从 array[0] 开始往下排，1，2,3。。。。当数据不够时会初始化为0



注意 
    一维数组允许  init  array []={1,2,3} 编译器会自动计算数组的长度

    但是 int arr[][]={2,3,4},不允许 二维数组必须指定列  int arr[][2]={2,3,4} 这样编译器材知道 //若不给他指定每一行里面的列数编译器根本就无法判断 到底多每一行改他多少个元素(列)，算一行 ，然后在根据
        js代码


        let initCount;//初始化元素的个数
        let  h =initCount/每一行个数(列数)
        h=Math.ceil(h);
        if(行数*列数>initCount){
            //不够的全部被编译器初始化为0
        }






```